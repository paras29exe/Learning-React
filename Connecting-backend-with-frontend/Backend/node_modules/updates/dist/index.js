#!/usr/bin/env node
import Zn from "url";
import Gs from "fs";
import Qn from "path";
import hr, { argv as Us, stdout as Ms, exit as Cr, cwd as Bs, env as et } from "node:process";
import { dirname as Jn, resolve as lt, basename as ct, join as pr } from "node:path";
import { readFileSync as Nr, truncateSync as ks, writeFileSync as zs, lstatSync as Lr, accessSync as Vs } from "node:fs";
import Ws from "node:os";
import Dr from "node:tty";
function Xs(t, e) {
  for (var r = 0; r < e.length; r++) {
    const n = e[r];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in t)) {
          const s = Object.getOwnPropertyDescriptor(n, i);
          s && Object.defineProperty(t, i, s.get ? s : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }));
}
function qs({ onlyFirst: t = !1 } = {}) {
  const e = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(e, t ? void 0 : "g");
}
function Ge(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Lt, Pr;
function es() {
  if (Pr)
    return Lt;
  Pr = 1;
  function t(n, i) {
    var s = n;
    i.slice(0, -1).forEach(function(l) {
      s = s[l] || {};
    });
    var o = i[i.length - 1];
    return o in s;
  }
  function e(n) {
    return typeof n == "number" || /^0x[0-9a-f]+$/i.test(n) ? !0 : /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(n);
  }
  function r(n, i) {
    return i === "constructor" && typeof n[i] == "function" || i === "__proto__";
  }
  return Lt = function(n, i) {
    i || (i = {});
    var s = {
      bools: {},
      strings: {},
      unknownFn: null
    };
    typeof i.unknown == "function" && (s.unknownFn = i.unknown), typeof i.boolean == "boolean" && i.boolean ? s.allBools = !0 : [].concat(i.boolean).filter(Boolean).forEach(function(x) {
      s.bools[x] = !0;
    });
    var o = {};
    function l(x) {
      return o[x].some(function(T) {
        return s.bools[T];
      });
    }
    Object.keys(i.alias || {}).forEach(function(x) {
      o[x] = [].concat(i.alias[x]), o[x].forEach(function(T) {
        o[T] = [x].concat(o[x].filter(function(L) {
          return T !== L;
        }));
      });
    }), [].concat(i.string).filter(Boolean).forEach(function(x) {
      s.strings[x] = !0, o[x] && [].concat(o[x]).forEach(function(T) {
        s.strings[T] = !0;
      });
    });
    var a = i.default || {}, c = { _: [] };
    function u(x, T) {
      return s.allBools && /^--[^=]+$/.test(T) || s.strings[x] || s.bools[x] || o[x];
    }
    function f(x, T, L) {
      for (var m = x, A = 0; A < T.length - 1; A++) {
        var v = T[A];
        if (r(m, v))
          return;
        m[v] === void 0 && (m[v] = {}), (m[v] === Object.prototype || m[v] === Number.prototype || m[v] === String.prototype) && (m[v] = {}), m[v] === Array.prototype && (m[v] = []), m = m[v];
      }
      var S = T[T.length - 1];
      r(m, S) || ((m === Object.prototype || m === Number.prototype || m === String.prototype) && (m = {}), m === Array.prototype && (m = []), m[S] === void 0 || s.bools[S] || typeof m[S] == "boolean" ? m[S] = L : Array.isArray(m[S]) ? m[S].push(L) : m[S] = [m[S], L]);
    }
    function d(x, T, L) {
      if (!(L && s.unknownFn && !u(x, L) && s.unknownFn(L) === !1)) {
        var m = !s.strings[x] && e(T) ? Number(T) : T;
        f(c, x.split("."), m), (o[x] || []).forEach(function(A) {
          f(c, A.split("."), m);
        });
      }
    }
    Object.keys(s.bools).forEach(function(x) {
      d(x, a[x] === void 0 ? !1 : a[x]);
    });
    var p = [];
    n.indexOf("--") !== -1 && (p = n.slice(n.indexOf("--") + 1), n = n.slice(0, n.indexOf("--")));
    for (var y = 0; y < n.length; y++) {
      var E = n[y], w, $;
      if (/^--.+=/.test(E)) {
        var _ = E.match(/^--([^=]+)=([\s\S]*)$/);
        w = _[1];
        var G = _[2];
        s.bools[w] && (G = G !== "false"), d(w, G, E);
      } else if (/^--no-.+/.test(E))
        w = E.match(/^--no-(.+)/)[1], d(w, !1, E);
      else if (/^--.+/.test(E))
        w = E.match(/^--(.+)/)[1], $ = n[y + 1], $ !== void 0 && !/^(-|--)[^-]/.test($) && !s.bools[w] && !s.allBools && (!o[w] || !l(w)) ? (d(w, $, E), y += 1) : /^(true|false)$/.test($) ? (d(w, $ === "true", E), y += 1) : d(w, s.strings[w] ? "" : !0, E);
      else if (/^-[^-]+/.test(E)) {
        for (var C = E.slice(1, -1).split(""), D = !1, j = 0; j < C.length; j++) {
          if ($ = E.slice(j + 2), $ === "-") {
            d(C[j], $, E);
            continue;
          }
          if (/[A-Za-z]/.test(C[j]) && $[0] === "=") {
            d(C[j], $.slice(1), E), D = !0;
            break;
          }
          if (/[A-Za-z]/.test(C[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test($)) {
            d(C[j], $, E), D = !0;
            break;
          }
          if (C[j + 1] && C[j + 1].match(/\W/)) {
            d(C[j], E.slice(j + 2), E), D = !0;
            break;
          } else
            d(C[j], s.strings[C[j]] ? "" : !0, E);
        }
        w = E.slice(-1)[0], !D && w !== "-" && (n[y + 1] && !/^(-|--)[^-]/.test(n[y + 1]) && !s.bools[w] && (!o[w] || !l(w)) ? (d(w, n[y + 1], E), y += 1) : n[y + 1] && /^(true|false)$/.test(n[y + 1]) ? (d(w, n[y + 1] === "true", E), y += 1) : d(w, s.strings[w] ? "" : !0, E));
      } else if ((!s.unknownFn || s.unknownFn(E) !== !1) && c._.push(s.strings._ || !e(E) ? E : Number(E)), i.stopEarly) {
        c._.push.apply(c._, n.slice(y + 1));
        break;
      }
    }
    return Object.keys(a).forEach(function(x) {
      t(c, x.split(".")) || (f(c, x.split("."), a[x]), (o[x] || []).forEach(function(T) {
        f(c, T.split("."), a[x]);
      }));
    }), i["--"] ? c["--"] = p.slice() : p.forEach(function(x) {
      c._.push(x);
    }), c;
  }, Lt;
}
var Ks = es();
const Ys = /* @__PURE__ */ Ge(Ks);
function Zs(t) {
  return Buffer.from(t, "base64").toString("utf8");
}
function Qs(t) {
  return Buffer.from(t, "utf8").toString("base64");
}
var Js = {
  decodeBase64: Zs,
  encodeBase64: Qs
}, Re = {}, ve = {}, jr;
function ei() {
  if (jr)
    return ve;
  jr = 1, ve.parse = ve.decode = n, ve.stringify = ve.encode = e, ve.safe = s, ve.unsafe = o;
  var t = typeof process < "u" && process.platform === "win32" ? `\r
` : `
`;
  function e(l, a) {
    var c = [], u = "";
    typeof a == "string" ? a = {
      section: a,
      whitespace: !1
    } : (a = a || {}, a.whitespace = a.whitespace === !0);
    var f = a.whitespace ? " = " : "=";
    return Object.keys(l).forEach(function(d, p, y) {
      var E = l[d];
      E && Array.isArray(E) ? E.forEach(function(w) {
        u += s(d + "[]") + f + s(w) + `
`;
      }) : E && typeof E == "object" ? c.push(d) : u += s(d) + f + s(E) + t;
    }), a.section && u.length && (u = "[" + s(a.section) + "]" + t + u), c.forEach(function(d, p, y) {
      var E = r(d).join("\\."), w = (a.section ? a.section + "." : "") + E, $ = e(l[d], {
        section: w,
        whitespace: a.whitespace
      });
      u.length && $.length && (u += t), u += $;
    }), u;
  }
  function r(l) {
    return l.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(a) {
      return a.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
    });
  }
  function n(l) {
    var a = {}, c = a, u = null, f = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i, d = l.split(/[\r\n]+/g);
    return d.forEach(function(p, y, E) {
      if (!(!p || p.match(/^\s*[;#]/))) {
        var w = p.match(f);
        if (w) {
          if (w[1] !== void 0) {
            if (u = o(w[1]), u === "__proto__") {
              c = {};
              return;
            }
            c = a[u] = a[u] || {};
            return;
          }
          var $ = o(w[2]);
          if ($ !== "__proto__") {
            var _ = w[3] ? o(w[4]) : !0;
            switch (_) {
              case "true":
              case "false":
              case "null":
                _ = JSON.parse(_);
            }
            if ($.length > 2 && $.slice(-2) === "[]") {
              if ($ = $.substring(0, $.length - 2), $ === "__proto__")
                return;
              c[$] ? Array.isArray(c[$]) || (c[$] = [c[$]]) : c[$] = [];
            }
            Array.isArray(c[$]) ? c[$].push(_) : c[$] = _;
          }
        }
      }
    }), Object.keys(a).filter(function(p, y, E) {
      if (!a[p] || typeof a[p] != "object" || Array.isArray(a[p]))
        return !1;
      var w = r(p), $ = a, _ = w.pop(), G = _.replace(/\\\./g, ".");
      return w.forEach(function(C, D, j) {
        C !== "__proto__" && ((!$[C] || typeof $[C] != "object") && ($[C] = {}), $ = $[C]);
      }), $ === a && G === _ ? !1 : ($[G] = a[p], !0);
    }).forEach(function(p, y, E) {
      delete a[p];
    }), a;
  }
  function i(l) {
    return l.charAt(0) === '"' && l.slice(-1) === '"' || l.charAt(0) === "'" && l.slice(-1) === "'";
  }
  function s(l) {
    return typeof l != "string" || l.match(/[=\r\n]/) || l.match(/^\[/) || l.length > 1 && i(l) || l !== l.trim() ? JSON.stringify(l) : l.replace(/;/g, "\\;").replace(/#/g, "\\#");
  }
  function o(l, a) {
    if (l = (l || "").trim(), i(l)) {
      l.charAt(0) === "'" && (l = l.substr(1, l.length - 2));
      try {
        l = JSON.parse(l);
      } catch {
      }
    } else {
      for (var c = !1, u = "", f = 0, d = l.length; f < d; f++) {
        var p = l.charAt(f);
        if (c)
          "\\;#".indexOf(p) !== -1 ? u += p : u += "\\" + p, c = !1;
        else {
          if (";#".indexOf(p) !== -1)
            break;
          p === "\\" ? c = !0 : u += p;
        }
      }
      return c && (u += "\\"), u.trim();
    }
    return l;
  }
  return ve;
}
var Dt, Hr;
function ti() {
  if (Hr)
    return Dt;
  Hr = 1;
  var t = 1, e = 2;
  function r() {
    return "";
  }
  function n(i, s, o) {
    return i.slice(s, o).replace(/\S/g, " ");
  }
  return Dt = function(i, s) {
    s = s || {};
    for (var o, l, a = !1, c = !1, u = 0, f = "", d = s.whitespace === !1 ? r : n, p = 0; p < i.length; p++) {
      if (o = i[p], l = i[p + 1], !c && o === '"') {
        var y = i[p - 1] === "\\" && i[p - 2] !== "\\";
        y || (a = !a);
      }
      if (!a) {
        if (!c && o + l === "//")
          f += i.slice(u, p), u = p, c = t, p++;
        else if (c === t && o + l === `\r
`) {
          p++, c = !1, f += d(i, u, p), u = p;
          continue;
        } else if (c === t && o === `
`)
          c = !1, f += d(i, u, p), u = p;
        else if (!c && o + l === "/*") {
          f += i.slice(u, p), u = p, c = e, p++;
          continue;
        } else if (c === e && o + l === "*/") {
          p++, c = !1, f += d(i, u, p + 1), u = p + 1;
          continue;
        }
      }
    }
    return f + (c ? d(i.substr(u)) : i.substr(u));
  }, Dt;
}
var Fr;
function ri() {
  if (Fr)
    return Re;
  Fr = 1;
  var t = Gs, e = ei(), r = Qn, n = ti(), i = Re.parse = function(o) {
    return /^\s*{/.test(o) ? JSON.parse(n(o)) : e.parse(o);
  }, s = Re.file = function() {
    var o = [].slice.call(arguments).filter(function(c) {
      return c != null;
    });
    for (var l in o)
      if (typeof o[l] != "string")
        return;
    var a = r.join.apply(null, o);
    try {
      return t.readFileSync(a, "utf-8");
    } catch {
      return;
    }
  };
  return Re.json = function() {
    var o = s.apply(null, arguments);
    return o ? i(o) : null;
  }, Re.env = function(o, l) {
    l = l || process.env;
    var a = {}, c = o.length;
    for (var u in l)
      if (u.toLowerCase().indexOf(o.toLowerCase()) === 0) {
        for (var f = u.substring(c).split("__"), d; (d = f.indexOf("")) > -1; )
          f.splice(d, 1);
        var p = a;
        f.forEach(function(E, w) {
          !E || typeof p != "object" || (w === f.length - 1 && (p[E] = l[u]), p[E] === void 0 && (p[E] = {}), p = p[E]);
        });
      }
    return a;
  }, Re.find = function() {
    var o = r.join.apply(null, [].slice.call(arguments));
    function l(a, c) {
      var u = r.join(a, c);
      try {
        return t.statSync(u), u;
      } catch {
        if (r.dirname(a) !== a)
          return l(r.dirname(a), c);
      }
    }
    return l(process.cwd(), o);
  }, Re;
}
var Pt = { exports: {} };
var Gr;
function ni() {
  if (Gr)
    return Pt.exports;
  Gr = 1;
  function t(s) {
    return s instanceof Buffer || s instanceof Date || s instanceof RegExp;
  }
  function e(s) {
    if (s instanceof Buffer) {
      var o = Buffer.alloc ? Buffer.alloc(s.length) : new Buffer(s.length);
      return s.copy(o), o;
    } else {
      if (s instanceof Date)
        return new Date(s.getTime());
      if (s instanceof RegExp)
        return new RegExp(s);
      throw new Error("Unexpected situation");
    }
  }
  function r(s) {
    var o = [];
    return s.forEach(function(l, a) {
      typeof l == "object" && l !== null ? Array.isArray(l) ? o[a] = r(l) : t(l) ? o[a] = e(l) : o[a] = i({}, l) : o[a] = l;
    }), o;
  }
  function n(s, o) {
    return o === "__proto__" ? void 0 : s[o];
  }
  var i = Pt.exports = function() {
    if (arguments.length < 1 || typeof arguments[0] != "object")
      return !1;
    if (arguments.length < 2)
      return arguments[0];
    var s = arguments[0], o = Array.prototype.slice.call(arguments, 1), l, a;
    return o.forEach(function(c) {
      typeof c != "object" || c === null || Array.isArray(c) || Object.keys(c).forEach(function(u) {
        if (a = n(s, u), l = n(c, u), l !== s)
          if (typeof l != "object" || l === null) {
            s[u] = l;
            return;
          } else if (Array.isArray(l)) {
            s[u] = r(l);
            return;
          } else if (t(l)) {
            s[u] = e(l);
            return;
          } else if (typeof a != "object" || a === null || Array.isArray(a)) {
            s[u] = i({}, l);
            return;
          } else {
            s[u] = i(a, l);
            return;
          }
      });
    }), s;
  };
  return Pt.exports;
}
var jt, Ur;
function ts() {
  if (Ur)
    return jt;
  Ur = 1;
  var t = ri(), e = Qn.join, r = ni(), n = "/etc", i = process.platform === "win32", s = i ? process.env.USERPROFILE : process.env.HOME;
  return jt = function(o, l, a, c) {
    if (typeof o != "string")
      throw new Error("rc(name): name *must* be string");
    a || (a = es()(process.argv.slice(2))), l = (typeof l == "string" ? t.json(l) : l) || {}, c = c || t.parse;
    var u = t.env(o + "_"), f = [l], d = [];
    function p(y) {
      if (!(d.indexOf(y) >= 0)) {
        var E = t.file(y);
        E && (f.push(c(E)), d.push(y));
      }
    }
    return i || [
      e(n, o, "config"),
      e(n, o + "rc")
    ].forEach(p), s && [
      e(s, ".config", o, "config"),
      e(s, ".config", o),
      e(s, "." + o, "config"),
      e(s, "." + o + "rc")
    ].forEach(p), p(t.find("." + o + "rc")), u.config && p(u.config), a.config && p(a.config), r.apply(null, f.concat([
      u,
      a,
      d.length ? { configs: d, config: d[d.length - 1] } : void 0
    ]));
  }, jt;
}
var Ht = Zn, rs = Js, si = rs.decodeBase64, ii = rs.encodeBase64, Mr = ":_authToken", Br = ":_auth", kr = ":username", zr = ":_password", oi = function() {
  var t, e;
  return arguments.length >= 2 ? (t = arguments[0], e = arguments[1]) : typeof arguments[0] == "string" ? t = arguments[0] : e = arguments[0], e = e || {}, e.npmrc = e.npmrc || ts()("npm", { registry: "https://registry.npmjs.org/" }, {
    config: process.env.npm_config_userconfig || process.env.NPM_CONFIG_USERCONFIG
  }), t = t || e.npmrc.registry, ns(t, e) || ai(e.npmrc);
};
function ns(t, e) {
  for (var r = Ht.parse(t, !1, !0), n; n !== "/" && r.pathname !== n; ) {
    n = r.pathname || "/";
    var i = "//" + r.host + n.replace(/\/$/, ""), s = ci(i, e.npmrc);
    if (s)
      return s;
    if (!e.recursive)
      return /\/$/.test(t) ? void 0 : ns(Ht.resolve(t, "."), e);
    r.pathname = Ht.resolve(li(n), "..") || "/";
  }
}
function ai(t) {
  if (t._auth) {
    var e = $t(t._auth);
    return { token: e, type: "Basic" };
  }
}
function li(t) {
  return t[t.length - 1] === "/" ? t : t + "/";
}
function ci(t, e) {
  var r = ui(e[t + Mr] || e[t + "/" + Mr]);
  if (r)
    return r;
  var n = e[t + kr] || e[t + "/" + kr], i = e[t + zr] || e[t + "/" + zr], s = fi(n, i);
  if (s)
    return s;
  var o = hi(e[t + Br] || e[t + "/" + Br]);
  if (o)
    return o;
}
function $t(t) {
  return t.replace(/^\$\{?([^}]*)\}?$/, function(e, r) {
    return process.env[r];
  });
}
function ui(t) {
  if (t) {
    var e = $t(t);
    return { token: e, type: "Bearer" };
  }
}
function fi(t, e) {
  if (!(!t || !e)) {
    var r = si($t(e)), n = ii(t + ":" + r);
    return {
      token: n,
      type: "Basic",
      password: r,
      username: t
    };
  }
}
function hi(t) {
  if (t) {
    var e = $t(t);
    return { token: e, type: "Basic" };
  }
}
const pi = /* @__PURE__ */ Ge(oi);
var di = ts();
const gi = /* @__PURE__ */ Ge(di);
var or = { exports: {} };
const mi = "2.0.0", Ei = 256, $i = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, yi = 16;
var yt = {
  SEMVER_SPEC_VERSION: mi,
  MAX_LENGTH: Ei,
  MAX_SAFE_INTEGER: $i,
  MAX_SAFE_COMPONENT_LENGTH: yi
};
const vi = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {
};
var vt = vi;
(function(t, e) {
  const { MAX_SAFE_COMPONENT_LENGTH: r } = yt, n = vt;
  e = t.exports = {};
  const i = e.re = [], s = e.src = [], o = e.t = {};
  let l = 0;
  const a = (c, u, f) => {
    const d = l++;
    n(c, d, u), o[c] = d, s[d] = u, i[d] = new RegExp(u, f ? "g" : void 0);
  };
  a("NUMERICIDENTIFIER", "0|[1-9]\\d*"), a("NUMERICIDENTIFIERLOOSE", "[0-9]+"), a("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), a("MAINVERSION", `(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})\\.(${s[o.NUMERICIDENTIFIER]})`), a("MAINVERSIONLOOSE", `(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})\\.(${s[o.NUMERICIDENTIFIERLOOSE]})`), a("PRERELEASEIDENTIFIER", `(?:${s[o.NUMERICIDENTIFIER]}|${s[o.NONNUMERICIDENTIFIER]})`), a("PRERELEASEIDENTIFIERLOOSE", `(?:${s[o.NUMERICIDENTIFIERLOOSE]}|${s[o.NONNUMERICIDENTIFIER]})`), a("PRERELEASE", `(?:-(${s[o.PRERELEASEIDENTIFIER]}(?:\\.${s[o.PRERELEASEIDENTIFIER]})*))`), a("PRERELEASELOOSE", `(?:-?(${s[o.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${s[o.PRERELEASEIDENTIFIERLOOSE]})*))`), a("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), a("BUILD", `(?:\\+(${s[o.BUILDIDENTIFIER]}(?:\\.${s[o.BUILDIDENTIFIER]})*))`), a("FULLPLAIN", `v?${s[o.MAINVERSION]}${s[o.PRERELEASE]}?${s[o.BUILD]}?`), a("FULL", `^${s[o.FULLPLAIN]}$`), a("LOOSEPLAIN", `[v=\\s]*${s[o.MAINVERSIONLOOSE]}${s[o.PRERELEASELOOSE]}?${s[o.BUILD]}?`), a("LOOSE", `^${s[o.LOOSEPLAIN]}$`), a("GTLT", "((?:<|>)?=?)"), a("XRANGEIDENTIFIERLOOSE", `${s[o.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), a("XRANGEIDENTIFIER", `${s[o.NUMERICIDENTIFIER]}|x|X|\\*`), a("XRANGEPLAIN", `[v=\\s]*(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:\\.(${s[o.XRANGEIDENTIFIER]})(?:${s[o.PRERELEASE]})?${s[o.BUILD]}?)?)?`), a("XRANGEPLAINLOOSE", `[v=\\s]*(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:\\.(${s[o.XRANGEIDENTIFIERLOOSE]})(?:${s[o.PRERELEASELOOSE]})?${s[o.BUILD]}?)?)?`), a("XRANGE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAIN]}$`), a("XRANGELOOSE", `^${s[o.GTLT]}\\s*${s[o.XRANGEPLAINLOOSE]}$`), a("COERCE", `(^|[^\\d])(\\d{1,${r}})(?:\\.(\\d{1,${r}}))?(?:\\.(\\d{1,${r}}))?(?:$|[^\\d])`), a("COERCERTL", s[o.COERCE], !0), a("LONETILDE", "(?:~>?)"), a("TILDETRIM", `(\\s*)${s[o.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", a("TILDE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAIN]}$`), a("TILDELOOSE", `^${s[o.LONETILDE]}${s[o.XRANGEPLAINLOOSE]}$`), a("LONECARET", "(?:\\^)"), a("CARETTRIM", `(\\s*)${s[o.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", a("CARET", `^${s[o.LONECARET]}${s[o.XRANGEPLAIN]}$`), a("CARETLOOSE", `^${s[o.LONECARET]}${s[o.XRANGEPLAINLOOSE]}$`), a("COMPARATORLOOSE", `^${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]})$|^$`), a("COMPARATOR", `^${s[o.GTLT]}\\s*(${s[o.FULLPLAIN]})$|^$`), a("COMPARATORTRIM", `(\\s*)${s[o.GTLT]}\\s*(${s[o.LOOSEPLAIN]}|${s[o.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", a("HYPHENRANGE", `^\\s*(${s[o.XRANGEPLAIN]})\\s+-\\s+(${s[o.XRANGEPLAIN]})\\s*$`), a("HYPHENRANGELOOSE", `^\\s*(${s[o.XRANGEPLAINLOOSE]})\\s+-\\s+(${s[o.XRANGEPLAINLOOSE]})\\s*$`), a("STAR", "(<|>)?=?\\s*\\*"), a("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), a("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(or, or.exports);
var Ue = or.exports;
const wi = ["includePrerelease", "loose", "rtl"], Ai = (t) => t ? typeof t != "object" ? { loose: !0 } : wi.filter((e) => t[e]).reduce((e, r) => (e[r] = !0, e), {}) : {};
var wt = Ai;
const Vr = /^[0-9]+$/, ss = (t, e) => {
  const r = Vr.test(t), n = Vr.test(e);
  return r && n && (t = +t, e = +e), t === e ? 0 : r && !n ? -1 : n && !r ? 1 : t < e ? -1 : 1;
}, bi = (t, e) => ss(e, t);
var is = {
  compareIdentifiers: ss,
  rcompareIdentifiers: bi
};
const tt = vt, { MAX_LENGTH: Wr, MAX_SAFE_INTEGER: rt } = yt, { re: Xr, t: qr } = Ue, Ri = wt, { compareIdentifiers: Ce } = is;
let _i = class ue {
  constructor(e, r) {
    if (r = Ri(r), e instanceof ue) {
      if (e.loose === !!r.loose && e.includePrerelease === !!r.includePrerelease)
        return e;
      e = e.version;
    } else if (typeof e != "string")
      throw new TypeError(`Invalid Version: ${e}`);
    if (e.length > Wr)
      throw new TypeError(
        `version is longer than ${Wr} characters`
      );
    tt("SemVer", e, r), this.options = r, this.loose = !!r.loose, this.includePrerelease = !!r.includePrerelease;
    const n = e.trim().match(r.loose ? Xr[qr.LOOSE] : Xr[qr.FULL]);
    if (!n)
      throw new TypeError(`Invalid Version: ${e}`);
    if (this.raw = e, this.major = +n[1], this.minor = +n[2], this.patch = +n[3], this.major > rt || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > rt || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > rt || this.patch < 0)
      throw new TypeError("Invalid patch version");
    n[4] ? this.prerelease = n[4].split(".").map((i) => {
      if (/^[0-9]+$/.test(i)) {
        const s = +i;
        if (s >= 0 && s < rt)
          return s;
      }
      return i;
    }) : this.prerelease = [], this.build = n[5] ? n[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(e) {
    if (tt("SemVer.compare", this.version, this.options, e), !(e instanceof ue)) {
      if (typeof e == "string" && e === this.version)
        return 0;
      e = new ue(e, this.options);
    }
    return e.version === this.version ? 0 : this.compareMain(e) || this.comparePre(e);
  }
  compareMain(e) {
    return e instanceof ue || (e = new ue(e, this.options)), Ce(this.major, e.major) || Ce(this.minor, e.minor) || Ce(this.patch, e.patch);
  }
  comparePre(e) {
    if (e instanceof ue || (e = new ue(e, this.options)), this.prerelease.length && !e.prerelease.length)
      return -1;
    if (!this.prerelease.length && e.prerelease.length)
      return 1;
    if (!this.prerelease.length && !e.prerelease.length)
      return 0;
    let r = 0;
    do {
      const n = this.prerelease[r], i = e.prerelease[r];
      if (tt("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return Ce(n, i);
    } while (++r);
  }
  compareBuild(e) {
    e instanceof ue || (e = new ue(e, this.options));
    let r = 0;
    do {
      const n = this.build[r], i = e.build[r];
      if (tt("prerelease compare", r, n, i), n === void 0 && i === void 0)
        return 0;
      if (i === void 0)
        return 1;
      if (n === void 0)
        return -1;
      if (n === i)
        continue;
      return Ce(n, i);
    } while (++r);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(e, r) {
    switch (e) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", r);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", r);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", r), this.inc("pre", r);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", r), this.inc("pre", r);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          let n = this.prerelease.length;
          for (; --n >= 0; )
            typeof this.prerelease[n] == "number" && (this.prerelease[n]++, n = -2);
          n === -1 && this.prerelease.push(0);
        }
        r && (Ce(this.prerelease[0], r) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [r, 0]) : this.prerelease = [r, 0]);
        break;
      default:
        throw new Error(`invalid increment argument: ${e}`);
    }
    return this.format(), this.raw = this.version, this;
  }
};
var re = _i;
const { MAX_LENGTH: Si } = yt, { re: Kr, t: Yr } = Ue, Zr = re, Oi = wt, Ti = (t, e) => {
  if (e = Oi(e), t instanceof Zr)
    return t;
  if (typeof t != "string" || t.length > Si || !(e.loose ? Kr[Yr.LOOSE] : Kr[Yr.FULL]).test(t))
    return null;
  try {
    return new Zr(t, e);
  } catch {
    return null;
  }
};
var Me = Ti;
const Ii = Me, xi = (t, e) => {
  const r = Ii(t, e);
  return r ? r.version : null;
};
var Ci = xi;
const Ni = Me, Li = (t, e) => {
  const r = Ni(t.trim().replace(/^[=v]+/, ""), e);
  return r ? r.version : null;
};
var Di = Li;
const Qr = re, Pi = (t, e, r, n) => {
  typeof r == "string" && (n = r, r = void 0);
  try {
    return new Qr(
      t instanceof Qr ? t.version : t,
      r
    ).inc(e, n).version;
  } catch {
    return null;
  }
};
var ji = Pi;
const Jr = re, Hi = (t, e, r) => new Jr(t, r).compare(new Jr(e, r));
var le = Hi;
const Fi = le, Gi = (t, e, r) => Fi(t, e, r) === 0;
var dr = Gi;
const en = Me, Ui = dr, Mi = (t, e) => {
  if (Ui(t, e))
    return null;
  {
    const r = en(t), n = en(e), i = r.prerelease.length || n.prerelease.length, s = i ? "pre" : "", o = i ? "prerelease" : "";
    for (const l in r)
      if ((l === "major" || l === "minor" || l === "patch") && r[l] !== n[l])
        return s + l;
    return o;
  }
};
var Bi = Mi;
const ki = re, zi = (t, e) => new ki(t, e).major;
var Vi = zi;
const Wi = re, Xi = (t, e) => new Wi(t, e).minor;
var qi = Xi;
const Ki = re, Yi = (t, e) => new Ki(t, e).patch;
var Zi = Yi;
const Qi = Me, Ji = (t, e) => {
  const r = Qi(t, e);
  return r && r.prerelease.length ? r.prerelease : null;
};
var eo = Ji;
const to = le, ro = (t, e, r) => to(e, t, r);
var no = ro;
const so = le, io = (t, e) => so(t, e, !0);
var oo = io;
const tn = re, ao = (t, e, r) => {
  const n = new tn(t, r), i = new tn(e, r);
  return n.compare(i) || n.compareBuild(i);
};
var gr = ao;
const lo = gr, co = (t, e) => t.sort((r, n) => lo(r, n, e));
var uo = co;
const fo = gr, ho = (t, e) => t.sort((r, n) => fo(n, r, e));
var po = ho;
const go = le, mo = (t, e, r) => go(t, e, r) > 0;
var At = mo;
const Eo = le, $o = (t, e, r) => Eo(t, e, r) < 0;
var mr = $o;
const yo = le, vo = (t, e, r) => yo(t, e, r) !== 0;
var os = vo;
const wo = le, Ao = (t, e, r) => wo(t, e, r) >= 0;
var Er = Ao;
const bo = le, Ro = (t, e, r) => bo(t, e, r) <= 0;
var $r = Ro;
const _o = dr, So = os, Oo = At, To = Er, Io = mr, xo = $r, Co = (t, e, r, n) => {
  switch (e) {
    case "===":
      return typeof t == "object" && (t = t.version), typeof r == "object" && (r = r.version), t === r;
    case "!==":
      return typeof t == "object" && (t = t.version), typeof r == "object" && (r = r.version), t !== r;
    case "":
    case "=":
    case "==":
      return _o(t, r, n);
    case "!=":
      return So(t, r, n);
    case ">":
      return Oo(t, r, n);
    case ">=":
      return To(t, r, n);
    case "<":
      return Io(t, r, n);
    case "<=":
      return xo(t, r, n);
    default:
      throw new TypeError(`Invalid operator: ${e}`);
  }
};
var as = Co;
const No = re, Lo = Me, { re: nt, t: st } = Ue, Do = (t, e) => {
  if (t instanceof No)
    return t;
  if (typeof t == "number" && (t = String(t)), typeof t != "string")
    return null;
  e = e || {};
  let r = null;
  if (!e.rtl)
    r = t.match(nt[st.COERCE]);
  else {
    let n;
    for (; (n = nt[st.COERCERTL].exec(t)) && (!r || r.index + r[0].length !== t.length); )
      (!r || n.index + n[0].length !== r.index + r[0].length) && (r = n), nt[st.COERCERTL].lastIndex = n.index + n[1].length + n[2].length;
    nt[st.COERCERTL].lastIndex = -1;
  }
  return r === null ? null : Lo(`${r[2]}.${r[3] || "0"}.${r[4] || "0"}`, e);
};
var Po = Do, Ft, rn;
function jo() {
  return rn || (rn = 1, Ft = function(t) {
    t.prototype[Symbol.iterator] = function* () {
      for (let e = this.head; e; e = e.next)
        yield e.value;
    };
  }), Ft;
}
var Ho = z;
z.Node = Te;
z.create = z;
function z(t) {
  var e = this;
  if (e instanceof z || (e = new z()), e.tail = null, e.head = null, e.length = 0, t && typeof t.forEach == "function")
    t.forEach(function(i) {
      e.push(i);
    });
  else if (arguments.length > 0)
    for (var r = 0, n = arguments.length; r < n; r++)
      e.push(arguments[r]);
  return e;
}
z.prototype.removeNode = function(t) {
  if (t.list !== this)
    throw new Error("removing node which does not belong to this list");
  var e = t.next, r = t.prev;
  return e && (e.prev = r), r && (r.next = e), t === this.head && (this.head = e), t === this.tail && (this.tail = r), t.list.length--, t.next = null, t.prev = null, t.list = null, e;
};
z.prototype.unshiftNode = function(t) {
  if (t !== this.head) {
    t.list && t.list.removeNode(t);
    var e = this.head;
    t.list = this, t.next = e, e && (e.prev = t), this.head = t, this.tail || (this.tail = t), this.length++;
  }
};
z.prototype.pushNode = function(t) {
  if (t !== this.tail) {
    t.list && t.list.removeNode(t);
    var e = this.tail;
    t.list = this, t.prev = e, e && (e.next = t), this.tail = t, this.head || (this.head = t), this.length++;
  }
};
z.prototype.push = function() {
  for (var t = 0, e = arguments.length; t < e; t++)
    Go(this, arguments[t]);
  return this.length;
};
z.prototype.unshift = function() {
  for (var t = 0, e = arguments.length; t < e; t++)
    Uo(this, arguments[t]);
  return this.length;
};
z.prototype.pop = function() {
  if (this.tail) {
    var t = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, t;
  }
};
z.prototype.shift = function() {
  if (this.head) {
    var t = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, t;
  }
};
z.prototype.forEach = function(t, e) {
  e = e || this;
  for (var r = this.head, n = 0; r !== null; n++)
    t.call(e, r.value, n, this), r = r.next;
};
z.prototype.forEachReverse = function(t, e) {
  e = e || this;
  for (var r = this.tail, n = this.length - 1; r !== null; n--)
    t.call(e, r.value, n, this), r = r.prev;
};
z.prototype.get = function(t) {
  for (var e = 0, r = this.head; r !== null && e < t; e++)
    r = r.next;
  if (e === t && r !== null)
    return r.value;
};
z.prototype.getReverse = function(t) {
  for (var e = 0, r = this.tail; r !== null && e < t; e++)
    r = r.prev;
  if (e === t && r !== null)
    return r.value;
};
z.prototype.map = function(t, e) {
  e = e || this;
  for (var r = new z(), n = this.head; n !== null; )
    r.push(t.call(e, n.value, this)), n = n.next;
  return r;
};
z.prototype.mapReverse = function(t, e) {
  e = e || this;
  for (var r = new z(), n = this.tail; n !== null; )
    r.push(t.call(e, n.value, this)), n = n.prev;
  return r;
};
z.prototype.reduce = function(t, e) {
  var r, n = this.head;
  if (arguments.length > 1)
    r = e;
  else if (this.head)
    n = this.head.next, r = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = 0; n !== null; i++)
    r = t(r, n.value, i), n = n.next;
  return r;
};
z.prototype.reduceReverse = function(t, e) {
  var r, n = this.tail;
  if (arguments.length > 1)
    r = e;
  else if (this.tail)
    n = this.tail.prev, r = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var i = this.length - 1; n !== null; i--)
    r = t(r, n.value, i), n = n.prev;
  return r;
};
z.prototype.toArray = function() {
  for (var t = new Array(this.length), e = 0, r = this.head; r !== null; e++)
    t[e] = r.value, r = r.next;
  return t;
};
z.prototype.toArrayReverse = function() {
  for (var t = new Array(this.length), e = 0, r = this.tail; r !== null; e++)
    t[e] = r.value, r = r.prev;
  return t;
};
z.prototype.slice = function(t, e) {
  e = e || this.length, e < 0 && (e += this.length), t = t || 0, t < 0 && (t += this.length);
  var r = new z();
  if (e < t || e < 0)
    return r;
  t < 0 && (t = 0), e > this.length && (e = this.length);
  for (var n = 0, i = this.head; i !== null && n < t; n++)
    i = i.next;
  for (; i !== null && n < e; n++, i = i.next)
    r.push(i.value);
  return r;
};
z.prototype.sliceReverse = function(t, e) {
  e = e || this.length, e < 0 && (e += this.length), t = t || 0, t < 0 && (t += this.length);
  var r = new z();
  if (e < t || e < 0)
    return r;
  t < 0 && (t = 0), e > this.length && (e = this.length);
  for (var n = this.length, i = this.tail; i !== null && n > e; n--)
    i = i.prev;
  for (; i !== null && n > t; n--, i = i.prev)
    r.push(i.value);
  return r;
};
z.prototype.splice = function(t, e, ...r) {
  t > this.length && (t = this.length - 1), t < 0 && (t = this.length + t);
  for (var n = 0, i = this.head; i !== null && n < t; n++)
    i = i.next;
  for (var s = [], n = 0; i && n < e; n++)
    s.push(i.value), i = this.removeNode(i);
  i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
  for (var n = 0; n < r.length; n++)
    i = Fo(this, i, r[n]);
  return s;
};
z.prototype.reverse = function() {
  for (var t = this.head, e = this.tail, r = t; r !== null; r = r.prev) {
    var n = r.prev;
    r.prev = r.next, r.next = n;
  }
  return this.head = e, this.tail = t, this;
};
function Fo(t, e, r) {
  var n = e === t.head ? new Te(r, null, e, t) : new Te(r, e, e.next, t);
  return n.next === null && (t.tail = n), n.prev === null && (t.head = n), t.length++, n;
}
function Go(t, e) {
  t.tail = new Te(e, t.tail, null, t), t.head || (t.head = t.tail), t.length++;
}
function Uo(t, e) {
  t.head = new Te(e, null, t.head, t), t.tail || (t.tail = t.head), t.length++;
}
function Te(t, e, r, n) {
  if (!(this instanceof Te))
    return new Te(t, e, r, n);
  this.list = n, this.value = t, e ? (e.next = this, this.prev = e) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
}
try {
  jo()(z);
} catch {
}
const Mo = Ho, Se = Symbol("max"), me = Symbol("length"), Ne = Symbol("lengthCalculator"), We = Symbol("allowStale"), Oe = Symbol("maxAge"), ge = Symbol("dispose"), nn = Symbol("noDisposeOnSet"), Q = Symbol("lruList"), oe = Symbol("cache"), ls = Symbol("updateAgeOnGet"), Gt = () => 1;
let Bo = class {
  constructor(e) {
    if (typeof e == "number" && (e = { max: e }), e || (e = {}), e.max && (typeof e.max != "number" || e.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[Se] = e.max || 1 / 0;
    const r = e.length || Gt;
    if (this[Ne] = typeof r != "function" ? Gt : r, this[We] = e.stale || !1, e.maxAge && typeof e.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Oe] = e.maxAge || 0, this[ge] = e.dispose, this[nn] = e.noDisposeOnSet || !1, this[ls] = e.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(e) {
    if (typeof e != "number" || e < 0)
      throw new TypeError("max must be a non-negative number");
    this[Se] = e || 1 / 0, Be(this);
  }
  get max() {
    return this[Se];
  }
  set allowStale(e) {
    this[We] = !!e;
  }
  get allowStale() {
    return this[We];
  }
  set maxAge(e) {
    if (typeof e != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Oe] = e, Be(this);
  }
  get maxAge() {
    return this[Oe];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(e) {
    typeof e != "function" && (e = Gt), e !== this[Ne] && (this[Ne] = e, this[me] = 0, this[Q].forEach((r) => {
      r.length = this[Ne](r.value, r.key), this[me] += r.length;
    })), Be(this);
  }
  get lengthCalculator() {
    return this[Ne];
  }
  get length() {
    return this[me];
  }
  get itemCount() {
    return this[Q].length;
  }
  rforEach(e, r) {
    r = r || this;
    for (let n = this[Q].tail; n !== null; ) {
      const i = n.prev;
      sn(this, e, n, r), n = i;
    }
  }
  forEach(e, r) {
    r = r || this;
    for (let n = this[Q].head; n !== null; ) {
      const i = n.next;
      sn(this, e, n, r), n = i;
    }
  }
  keys() {
    return this[Q].toArray().map((e) => e.key);
  }
  values() {
    return this[Q].toArray().map((e) => e.value);
  }
  reset() {
    this[ge] && this[Q] && this[Q].length && this[Q].forEach((e) => this[ge](e.key, e.value)), this[oe] = /* @__PURE__ */ new Map(), this[Q] = new Mo(), this[me] = 0;
  }
  dump() {
    return this[Q].map((e) => ht(this, e) ? !1 : {
      k: e.key,
      v: e.value,
      e: e.now + (e.maxAge || 0)
    }).toArray().filter((e) => e);
  }
  dumpLru() {
    return this[Q];
  }
  set(e, r, n) {
    if (n = n || this[Oe], n && typeof n != "number")
      throw new TypeError("maxAge must be a number");
    const i = n ? Date.now() : 0, s = this[Ne](r, e);
    if (this[oe].has(e)) {
      if (s > this[Se])
        return Fe(this, this[oe].get(e)), !1;
      const a = this[oe].get(e).value;
      return this[ge] && (this[nn] || this[ge](e, a.value)), a.now = i, a.maxAge = n, a.value = r, this[me] += s - a.length, a.length = s, this.get(e), Be(this), !0;
    }
    const o = new ko(e, r, s, i, n);
    return o.length > this[Se] ? (this[ge] && this[ge](e, r), !1) : (this[me] += o.length, this[Q].unshift(o), this[oe].set(e, this[Q].head), Be(this), !0);
  }
  has(e) {
    if (!this[oe].has(e))
      return !1;
    const r = this[oe].get(e).value;
    return !ht(this, r);
  }
  get(e) {
    return Ut(this, e, !0);
  }
  peek(e) {
    return Ut(this, e, !1);
  }
  pop() {
    const e = this[Q].tail;
    return e ? (Fe(this, e), e.value) : null;
  }
  del(e) {
    Fe(this, this[oe].get(e));
  }
  load(e) {
    this.reset();
    const r = Date.now();
    for (let n = e.length - 1; n >= 0; n--) {
      const i = e[n], s = i.e || 0;
      if (s === 0)
        this.set(i.k, i.v);
      else {
        const o = s - r;
        o > 0 && this.set(i.k, i.v, o);
      }
    }
  }
  prune() {
    this[oe].forEach((e, r) => Ut(this, r, !1));
  }
};
const Ut = (t, e, r) => {
  const n = t[oe].get(e);
  if (n) {
    const i = n.value;
    if (ht(t, i)) {
      if (Fe(t, n), !t[We])
        return;
    } else
      r && (t[ls] && (n.value.now = Date.now()), t[Q].unshiftNode(n));
    return i.value;
  }
}, ht = (t, e) => {
  if (!e || !e.maxAge && !t[Oe])
    return !1;
  const r = Date.now() - e.now;
  return e.maxAge ? r > e.maxAge : t[Oe] && r > t[Oe];
}, Be = (t) => {
  if (t[me] > t[Se])
    for (let e = t[Q].tail; t[me] > t[Se] && e !== null; ) {
      const r = e.prev;
      Fe(t, e), e = r;
    }
}, Fe = (t, e) => {
  if (e) {
    const r = e.value;
    t[ge] && t[ge](r.key, r.value), t[me] -= r.length, t[oe].delete(r.key), t[Q].removeNode(e);
  }
};
class ko {
  constructor(e, r, n, i, s) {
    this.key = e, this.value = r, this.length = n, this.now = i, this.maxAge = s || 0;
  }
}
const sn = (t, e, r, n) => {
  let i = r.value;
  ht(t, i) && (Fe(t, r), t[We] || (i = void 0)), i && e.call(n, i.value, i.key, t);
};
var zo = Bo, Mt, on;
function ce() {
  if (on)
    return Mt;
  on = 1;
  class t {
    constructor(v, S) {
      if (S = n(S), v instanceof t)
        return v.loose === !!S.loose && v.includePrerelease === !!S.includePrerelease ? v : new t(v.raw, S);
      if (v instanceof i)
        return this.raw = v.value, this.set = [[v]], this.format(), this;
      if (this.options = S, this.loose = !!S.loose, this.includePrerelease = !!S.includePrerelease, this.raw = v, this.set = v.split("||").map((h) => this.parseRange(h.trim())).filter((h) => h.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${v}`);
      if (this.set.length > 1) {
        const h = this.set[0];
        if (this.set = this.set.filter((g) => !d(g[0])), this.set.length === 0)
          this.set = [h];
        else if (this.set.length > 1) {
          for (const g of this.set)
            if (g.length === 1 && p(g[0])) {
              this.set = [g];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((v) => v.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(v) {
      v = v.trim();
      const h = `parseRange:${Object.keys(this.options).join(",")}:${v}`, g = r.get(h);
      if (g)
        return g;
      const b = this.options.loose, R = b ? l[a.HYPHENRANGELOOSE] : l[a.HYPHENRANGE];
      v = v.replace(R, L(this.options.includePrerelease)), s("hyphen replace", v), v = v.replace(l[a.COMPARATORTRIM], c), s("comparator trim", v), v = v.replace(l[a.TILDETRIM], u), v = v.replace(l[a.CARETTRIM], f), v = v.split(/\s+/).join(" ");
      let N = v.split(" ").map((M) => E(M, this.options)).join(" ").split(/\s+/).map((M) => T(M, this.options));
      b && (N = N.filter((M) => (s("loose invalid filter", M, this.options), !!M.match(l[a.COMPARATORLOOSE])))), s("range list", N);
      const P = /* @__PURE__ */ new Map(), F = N.map((M) => new i(M, this.options));
      for (const M of F) {
        if (d(M))
          return [M];
        P.set(M.value, M);
      }
      P.size > 1 && P.has("") && P.delete("");
      const V = [...P.values()];
      return r.set(h, V), V;
    }
    intersects(v, S) {
      if (!(v instanceof t))
        throw new TypeError("a Range is required");
      return this.set.some((h) => y(h, S) && v.set.some((g) => y(g, S) && h.every((b) => g.every((R) => b.intersects(R, S)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(v) {
      if (!v)
        return !1;
      if (typeof v == "string")
        try {
          v = new o(v, this.options);
        } catch {
          return !1;
        }
      for (let S = 0; S < this.set.length; S++)
        if (m(this.set[S], v, this.options))
          return !0;
      return !1;
    }
  }
  Mt = t;
  const e = zo, r = new e({ max: 1e3 }), n = wt, i = bt(), s = vt, o = re, {
    re: l,
    t: a,
    comparatorTrimReplace: c,
    tildeTrimReplace: u,
    caretTrimReplace: f
  } = Ue, d = (A) => A.value === "<0.0.0-0", p = (A) => A.value === "", y = (A, v) => {
    let S = !0;
    const h = A.slice();
    let g = h.pop();
    for (; S && h.length; )
      S = h.every((b) => g.intersects(b, v)), g = h.pop();
    return S;
  }, E = (A, v) => (s("comp", A, v), A = G(A, v), s("caret", A), A = $(A, v), s("tildes", A), A = D(A, v), s("xrange", A), A = x(A, v), s("stars", A), A), w = (A) => !A || A.toLowerCase() === "x" || A === "*", $ = (A, v) => A.trim().split(/\s+/).map((S) => _(S, v)).join(" "), _ = (A, v) => {
    const S = v.loose ? l[a.TILDELOOSE] : l[a.TILDE];
    return A.replace(S, (h, g, b, R, N) => {
      s("tilde", A, h, g, b, R, N);
      let P;
      return w(g) ? P = "" : w(b) ? P = `>=${g}.0.0 <${+g + 1}.0.0-0` : w(R) ? P = `>=${g}.${b}.0 <${g}.${+b + 1}.0-0` : N ? (s("replaceTilde pr", N), P = `>=${g}.${b}.${R}-${N} <${g}.${+b + 1}.0-0`) : P = `>=${g}.${b}.${R} <${g}.${+b + 1}.0-0`, s("tilde return", P), P;
    });
  }, G = (A, v) => A.trim().split(/\s+/).map((S) => C(S, v)).join(" "), C = (A, v) => {
    s("caret", A, v);
    const S = v.loose ? l[a.CARETLOOSE] : l[a.CARET], h = v.includePrerelease ? "-0" : "";
    return A.replace(S, (g, b, R, N, P) => {
      s("caret", A, g, b, R, N, P);
      let F;
      return w(b) ? F = "" : w(R) ? F = `>=${b}.0.0${h} <${+b + 1}.0.0-0` : w(N) ? b === "0" ? F = `>=${b}.${R}.0${h} <${b}.${+R + 1}.0-0` : F = `>=${b}.${R}.0${h} <${+b + 1}.0.0-0` : P ? (s("replaceCaret pr", P), b === "0" ? R === "0" ? F = `>=${b}.${R}.${N}-${P} <${b}.${R}.${+N + 1}-0` : F = `>=${b}.${R}.${N}-${P} <${b}.${+R + 1}.0-0` : F = `>=${b}.${R}.${N}-${P} <${+b + 1}.0.0-0`) : (s("no pr"), b === "0" ? R === "0" ? F = `>=${b}.${R}.${N}${h} <${b}.${R}.${+N + 1}-0` : F = `>=${b}.${R}.${N}${h} <${b}.${+R + 1}.0-0` : F = `>=${b}.${R}.${N} <${+b + 1}.0.0-0`), s("caret return", F), F;
    });
  }, D = (A, v) => (s("replaceXRanges", A, v), A.split(/\s+/).map((S) => j(S, v)).join(" ")), j = (A, v) => {
    A = A.trim();
    const S = v.loose ? l[a.XRANGELOOSE] : l[a.XRANGE];
    return A.replace(S, (h, g, b, R, N, P) => {
      s("xRange", A, h, g, b, R, N, P);
      const F = w(b), V = F || w(R), M = V || w(N), ne = M;
      return g === "=" && ne && (g = ""), P = v.includePrerelease ? "-0" : "", F ? g === ">" || g === "<" ? h = "<0.0.0-0" : h = "*" : g && ne ? (V && (R = 0), N = 0, g === ">" ? (g = ">=", V ? (b = +b + 1, R = 0, N = 0) : (R = +R + 1, N = 0)) : g === "<=" && (g = "<", V ? b = +b + 1 : R = +R + 1), g === "<" && (P = "-0"), h = `${g + b}.${R}.${N}${P}`) : V ? h = `>=${b}.0.0${P} <${+b + 1}.0.0-0` : M && (h = `>=${b}.${R}.0${P} <${b}.${+R + 1}.0-0`), s("xRange return", h), h;
    });
  }, x = (A, v) => (s("replaceStars", A, v), A.trim().replace(l[a.STAR], "")), T = (A, v) => (s("replaceGTE0", A, v), A.trim().replace(l[v.includePrerelease ? a.GTE0PRE : a.GTE0], "")), L = (A) => (v, S, h, g, b, R, N, P, F, V, M, ne, ie) => (w(h) ? S = "" : w(g) ? S = `>=${h}.0.0${A ? "-0" : ""}` : w(b) ? S = `>=${h}.${g}.0${A ? "-0" : ""}` : R ? S = `>=${S}` : S = `>=${S}${A ? "-0" : ""}`, w(F) ? P = "" : w(V) ? P = `<${+F + 1}.0.0-0` : w(M) ? P = `<${F}.${+V + 1}.0-0` : ne ? P = `<=${F}.${V}.${M}-${ne}` : A ? P = `<${F}.${V}.${+M + 1}-0` : P = `<=${P}`, `${S} ${P}`.trim()), m = (A, v, S) => {
    for (let h = 0; h < A.length; h++)
      if (!A[h].test(v))
        return !1;
    if (v.prerelease.length && !S.includePrerelease) {
      for (let h = 0; h < A.length; h++)
        if (s(A[h].semver), A[h].semver !== i.ANY && A[h].semver.prerelease.length > 0) {
          const g = A[h].semver;
          if (g.major === v.major && g.minor === v.minor && g.patch === v.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Mt;
}
var Bt, an;
function bt() {
  if (an)
    return Bt;
  an = 1;
  const t = Symbol("SemVer ANY");
  class e {
    static get ANY() {
      return t;
    }
    constructor(u, f) {
      if (f = r(f), u instanceof e) {
        if (u.loose === !!f.loose)
          return u;
        u = u.value;
      }
      o("comparator", u, f), this.options = f, this.loose = !!f.loose, this.parse(u), this.semver === t ? this.value = "" : this.value = this.operator + this.semver.version, o("comp", this);
    }
    parse(u) {
      const f = this.options.loose ? n[i.COMPARATORLOOSE] : n[i.COMPARATOR], d = u.match(f);
      if (!d)
        throw new TypeError(`Invalid comparator: ${u}`);
      this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new l(d[2], this.options.loose) : this.semver = t;
    }
    toString() {
      return this.value;
    }
    test(u) {
      if (o("Comparator.test", u, this.options.loose), this.semver === t || u === t)
        return !0;
      if (typeof u == "string")
        try {
          u = new l(u, this.options);
        } catch {
          return !1;
        }
      return s(u, this.operator, this.semver, this.options);
    }
    intersects(u, f) {
      if (!(u instanceof e))
        throw new TypeError("a Comparator is required");
      if ((!f || typeof f != "object") && (f = {
        loose: !!f,
        includePrerelease: !1
      }), this.operator === "")
        return this.value === "" ? !0 : new a(u.value, f).test(this.value);
      if (u.operator === "")
        return u.value === "" ? !0 : new a(this.value, f).test(u.semver);
      const d = (this.operator === ">=" || this.operator === ">") && (u.operator === ">=" || u.operator === ">"), p = (this.operator === "<=" || this.operator === "<") && (u.operator === "<=" || u.operator === "<"), y = this.semver.version === u.semver.version, E = (this.operator === ">=" || this.operator === "<=") && (u.operator === ">=" || u.operator === "<="), w = s(this.semver, "<", u.semver, f) && (this.operator === ">=" || this.operator === ">") && (u.operator === "<=" || u.operator === "<"), $ = s(this.semver, ">", u.semver, f) && (this.operator === "<=" || this.operator === "<") && (u.operator === ">=" || u.operator === ">");
      return d || p || y && E || w || $;
    }
  }
  Bt = e;
  const r = wt, { re: n, t: i } = Ue, s = as, o = vt, l = re, a = ce();
  return Bt;
}
const Vo = ce(), Wo = (t, e, r) => {
  try {
    e = new Vo(e, r);
  } catch {
    return !1;
  }
  return e.test(t);
};
var Rt = Wo;
const Xo = ce(), qo = (t, e) => new Xo(t, e).set.map((r) => r.map((n) => n.value).join(" ").trim().split(" "));
var Ko = qo;
const Yo = re, Zo = ce(), Qo = (t, e, r) => {
  let n = null, i = null, s = null;
  try {
    s = new Zo(e, r);
  } catch {
    return null;
  }
  return t.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === -1) && (n = o, i = new Yo(n, r));
  }), n;
};
var Jo = Qo;
const ea = re, ta = ce(), ra = (t, e, r) => {
  let n = null, i = null, s = null;
  try {
    s = new ta(e, r);
  } catch {
    return null;
  }
  return t.forEach((o) => {
    s.test(o) && (!n || i.compare(o) === 1) && (n = o, i = new ea(n, r));
  }), n;
};
var na = ra;
const kt = re, sa = ce(), ln = At, ia = (t, e) => {
  t = new sa(t, e);
  let r = new kt("0.0.0");
  if (t.test(r) || (r = new kt("0.0.0-0"), t.test(r)))
    return r;
  r = null;
  for (let n = 0; n < t.set.length; ++n) {
    const i = t.set[n];
    let s = null;
    i.forEach((o) => {
      const l = new kt(o.semver.version);
      switch (o.operator) {
        case ">":
          l.prerelease.length === 0 ? l.patch++ : l.prerelease.push(0), l.raw = l.format();
        case "":
        case ">=":
          (!s || ln(l, s)) && (s = l);
          break;
        case "<":
        case "<=":
          break;
        default:
          throw new Error(`Unexpected operation: ${o.operator}`);
      }
    }), s && (!r || ln(r, s)) && (r = s);
  }
  return r && t.test(r) ? r : null;
};
var oa = ia;
const aa = ce(), la = (t, e) => {
  try {
    return new aa(t, e).range || "*";
  } catch {
    return null;
  }
};
var ca = la;
const ua = re, cs = bt(), { ANY: fa } = cs, ha = ce(), pa = Rt, cn = At, un = mr, da = $r, ga = Er, ma = (t, e, r, n) => {
  t = new ua(t, n), e = new ha(e, n);
  let i, s, o, l, a;
  switch (r) {
    case ">":
      i = cn, s = da, o = un, l = ">", a = ">=";
      break;
    case "<":
      i = un, s = ga, o = cn, l = "<", a = "<=";
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }
  if (pa(t, e, n))
    return !1;
  for (let c = 0; c < e.set.length; ++c) {
    const u = e.set[c];
    let f = null, d = null;
    if (u.forEach((p) => {
      p.semver === fa && (p = new cs(">=0.0.0")), f = f || p, d = d || p, i(p.semver, f.semver, n) ? f = p : o(p.semver, d.semver, n) && (d = p);
    }), f.operator === l || f.operator === a || (!d.operator || d.operator === l) && s(t, d.semver))
      return !1;
    if (d.operator === a && o(t, d.semver))
      return !1;
  }
  return !0;
};
var yr = ma;
const Ea = yr, $a = (t, e, r) => Ea(t, e, ">", r);
var ya = $a;
const va = yr, wa = (t, e, r) => va(t, e, "<", r);
var Aa = wa;
const fn = ce(), ba = (t, e, r) => (t = new fn(t, r), e = new fn(e, r), t.intersects(e));
var Ra = ba;
const _a = Rt, Sa = le;
var Oa = (t, e, r) => {
  const n = [];
  let i = null, s = null;
  const o = t.sort((u, f) => Sa(u, f, r));
  for (const u of o)
    _a(u, e, r) ? (s = u, i || (i = u)) : (s && n.push([i, s]), s = null, i = null);
  i && n.push([i, null]);
  const l = [];
  for (const [u, f] of n)
    u === f ? l.push(u) : !f && u === o[0] ? l.push("*") : f ? u === o[0] ? l.push(`<=${f}`) : l.push(`${u} - ${f}`) : l.push(`>=${u}`);
  const a = l.join(" || "), c = typeof e.raw == "string" ? e.raw : String(e);
  return a.length < c.length ? a : e;
};
const hn = ce(), ut = bt(), { ANY: zt } = ut, ke = Rt, vr = le, Ta = (t, e, r = {}) => {
  if (t === e)
    return !0;
  t = new hn(t, r), e = new hn(e, r);
  let n = !1;
  e:
    for (const i of t.set) {
      for (const s of e.set) {
        const o = Ia(i, s, r);
        if (n = n || o !== null, o)
          continue e;
      }
      if (n)
        return !1;
    }
  return !0;
}, Ia = (t, e, r) => {
  if (t === e)
    return !0;
  if (t.length === 1 && t[0].semver === zt) {
    if (e.length === 1 && e[0].semver === zt)
      return !0;
    r.includePrerelease ? t = [new ut(">=0.0.0-0")] : t = [new ut(">=0.0.0")];
  }
  if (e.length === 1 && e[0].semver === zt) {
    if (r.includePrerelease)
      return !0;
    e = [new ut(">=0.0.0")];
  }
  const n = /* @__PURE__ */ new Set();
  let i, s;
  for (const p of t)
    p.operator === ">" || p.operator === ">=" ? i = pn(i, p, r) : p.operator === "<" || p.operator === "<=" ? s = dn(s, p, r) : n.add(p.semver);
  if (n.size > 1)
    return null;
  let o;
  if (i && s) {
    if (o = vr(i.semver, s.semver, r), o > 0)
      return null;
    if (o === 0 && (i.operator !== ">=" || s.operator !== "<="))
      return null;
  }
  for (const p of n) {
    if (i && !ke(p, String(i), r) || s && !ke(p, String(s), r))
      return null;
    for (const y of e)
      if (!ke(p, String(y), r))
        return !1;
    return !0;
  }
  let l, a, c, u, f = s && !r.includePrerelease && s.semver.prerelease.length ? s.semver : !1, d = i && !r.includePrerelease && i.semver.prerelease.length ? i.semver : !1;
  f && f.prerelease.length === 1 && s.operator === "<" && f.prerelease[0] === 0 && (f = !1);
  for (const p of e) {
    if (u = u || p.operator === ">" || p.operator === ">=", c = c || p.operator === "<" || p.operator === "<=", i) {
      if (d && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === d.major && p.semver.minor === d.minor && p.semver.patch === d.patch && (d = !1), p.operator === ">" || p.operator === ">=") {
        if (l = pn(i, p, r), l === p && l !== i)
          return !1;
      } else if (i.operator === ">=" && !ke(i.semver, String(p), r))
        return !1;
    }
    if (s) {
      if (f && p.semver.prerelease && p.semver.prerelease.length && p.semver.major === f.major && p.semver.minor === f.minor && p.semver.patch === f.patch && (f = !1), p.operator === "<" || p.operator === "<=") {
        if (a = dn(s, p, r), a === p && a !== s)
          return !1;
      } else if (s.operator === "<=" && !ke(s.semver, String(p), r))
        return !1;
    }
    if (!p.operator && (s || i) && o !== 0)
      return !1;
  }
  return !(i && c && !s && o !== 0 || s && u && !i && o !== 0 || d || f);
}, pn = (t, e, r) => {
  if (!t)
    return e;
  const n = vr(t.semver, e.semver, r);
  return n > 0 ? t : n < 0 || e.operator === ">" && t.operator === ">=" ? e : t;
}, dn = (t, e, r) => {
  if (!t)
    return e;
  const n = vr(t.semver, e.semver, r);
  return n < 0 ? t : n > 0 || e.operator === "<" && t.operator === "<=" ? e : t;
};
var xa = Ta;
const Vt = Ue, Ca = yt, Na = re, gn = is, La = Me, Da = Ci, Pa = Di, ja = ji, Ha = Bi, Fa = Vi, Ga = qi, Ua = Zi, Ma = eo, Ba = le, ka = no, za = oo, Va = gr, Wa = uo, Xa = po, qa = At, Ka = mr, Ya = dr, Za = os, Qa = Er, Ja = $r, el = as, tl = Po, rl = bt(), nl = ce(), sl = Rt, il = Ko, ol = Jo, al = na, ll = oa, cl = ca, ul = yr, fl = ya, hl = Aa, pl = Ra, dl = Oa, gl = xa;
var J = {
  parse: La,
  valid: Da,
  clean: Pa,
  inc: ja,
  diff: Ha,
  major: Fa,
  minor: Ga,
  patch: Ua,
  prerelease: Ma,
  compare: Ba,
  rcompare: ka,
  compareLoose: za,
  compareBuild: Va,
  sort: Wa,
  rsort: Xa,
  gt: qa,
  lt: Ka,
  eq: Ya,
  neq: Za,
  gte: Qa,
  lte: Ja,
  cmp: el,
  coerce: tl,
  Comparator: rl,
  Range: nl,
  satisfies: sl,
  toComparators: il,
  maxSatisfying: ol,
  minSatisfying: al,
  minVersion: ll,
  validRange: cl,
  outside: ul,
  gtr: fl,
  ltr: hl,
  intersects: pl,
  simplifyRange: dl,
  subset: gl,
  SemVer: Na,
  re: Vt.re,
  src: Vt.src,
  tokens: Vt.t,
  SEMVER_SPEC_VERSION: Ca.SEMVER_SPEC_VERSION,
  compareIdentifiers: gn.compareIdentifiers,
  rcompareIdentifiers: gn.rcompareIdentifiers
}, ml = function(t, e) {
  e || (e = {});
  var r = e.hsep === void 0 ? "  " : e.hsep, n = e.align || [], i = e.stringLength || function(a) {
    return String(a).length;
  }, s = En(t, function(a, c) {
    return $n(c, function(u, f) {
      var d = mn(u);
      (!a[f] || d > a[f]) && (a[f] = d);
    }), a;
  }, []), o = it(t, function(a) {
    return it(a, function(c, u) {
      var f = String(c);
      if (n[u] === ".") {
        var d = mn(f), p = s[u] + (/\./.test(f) ? 1 : 2) - (i(f) - d);
        return f + Array(p).join(" ");
      } else
        return f;
    });
  }), l = En(o, function(a, c) {
    return $n(c, function(u, f) {
      var d = i(u);
      (!a[f] || d > a[f]) && (a[f] = d);
    }), a;
  }, []);
  return it(o, function(a) {
    return it(a, function(c, u) {
      var f = l[u] - i(c) || 0, d = Array(Math.max(f + 1, 1)).join(" ");
      return n[u] === "r" || n[u] === "." ? d + c : n[u] === "c" ? Array(Math.ceil(f / 2 + 1)).join(" ") + c + Array(Math.floor(f / 2 + 1)).join(" ") : c + d;
    }).join(r).replace(/\s+$/, "");
  }).join(`
`);
};
function mn(t) {
  var e = /\.[^.]*$/.exec(t);
  return e ? e.index + 1 : t.length;
}
function En(t, e, r) {
  if (t.reduce)
    return t.reduce(e, r);
  for (var n = 0, i = arguments.length >= 3 ? r : t[n++]; n < t.length; n++)
    e(i, t[n], n);
  return i;
}
function $n(t, e) {
  if (t.forEach)
    return t.forEach(e);
  for (var r = 0; r < t.length; r++)
    e.call(t, t[r], r);
}
function it(t, e) {
  if (t.map)
    return t.map(e);
  for (var r = [], n = 0; n < t.length; n++)
    r.push(e.call(t, t[n], n));
  return r;
}
const El = /* @__PURE__ */ Ge(ml);
var _t = {};
Object.defineProperty(_t, "__esModule", { value: !0 });
_t.LRUCache = void 0;
const Le = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date, us = /* @__PURE__ */ new Set(), ar = typeof process == "object" && process ? process : {}, fs = (t, e, r, n) => {
  typeof ar.emitWarning == "function" ? ar.emitWarning(t, e, r, n) : console.error(`[${r}] ${e}: ${t}`);
};
let pt = globalThis.AbortController, yn = globalThis.AbortSignal;
if (typeof pt > "u") {
  yn = class {
    onabort;
    _onabort = [];
    reason;
    aborted = !1;
    addEventListener(n, i) {
      this._onabort.push(i);
    }
  }, pt = class {
    constructor() {
      e();
    }
    signal = new yn();
    abort(n) {
      if (!this.signal.aborted) {
        this.signal.reason = n, this.signal.aborted = !0;
        for (const i of this.signal._onabort)
          i(n);
        this.signal.onabort?.(n);
      }
    }
  };
  let t = ar.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
  const e = () => {
    t && (t = !1, fs("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", e));
  };
}
const $l = (t) => !us.has(t), we = (t) => t && t === Math.floor(t) && t > 0 && isFinite(t), hs = (t) => we(t) ? t <= Math.pow(2, 8) ? Uint8Array : t <= Math.pow(2, 16) ? Uint16Array : t <= Math.pow(2, 32) ? Uint32Array : t <= Number.MAX_SAFE_INTEGER ? ft : null : null;
class ft extends Array {
  constructor(e) {
    super(e), this.fill(0);
  }
}
class je {
  heap;
  length;
  // private constructor
  static #r = !1;
  static create(e) {
    const r = hs(e);
    if (!r)
      return [];
    je.#r = !0;
    const n = new je(e, r);
    return je.#r = !1, n;
  }
  constructor(e, r) {
    if (!je.#r)
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new r(e), this.length = 0;
  }
  push(e) {
    this.heap[this.length++] = e;
  }
  pop() {
    return this.heap[--this.length];
  }
}
let yl = class ps {
  // properties coming in from the options of these, only max and maxSize
  // really *need* to be protected. The rest can be modified, as they just
  // set defaults for various methods.
  #r;
  #i;
  #t;
  #m;
  #I;
  /**
   * {@link LRUCache.OptionsBase.ttl}
   */
  ttl;
  /**
   * {@link LRUCache.OptionsBase.ttlResolution}
   */
  ttlResolution;
  /**
   * {@link LRUCache.OptionsBase.ttlAutopurge}
   */
  ttlAutopurge;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnGet}
   */
  updateAgeOnGet;
  /**
   * {@link LRUCache.OptionsBase.updateAgeOnHas}
   */
  updateAgeOnHas;
  /**
   * {@link LRUCache.OptionsBase.allowStale}
   */
  allowStale;
  /**
   * {@link LRUCache.OptionsBase.noDisposeOnSet}
   */
  noDisposeOnSet;
  /**
   * {@link LRUCache.OptionsBase.noUpdateTTL}
   */
  noUpdateTTL;
  /**
   * {@link LRUCache.OptionsBase.maxEntrySize}
   */
  maxEntrySize;
  /**
   * {@link LRUCache.OptionsBase.sizeCalculation}
   */
  sizeCalculation;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
   */
  noDeleteOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
   */
  noDeleteOnStaleGet;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
   */
  allowStaleOnFetchAbort;
  /**
   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
   */
  allowStaleOnFetchRejection;
  /**
   * {@link LRUCache.OptionsBase.ignoreFetchAbort}
   */
  ignoreFetchAbort;
  // computed properties
  #a;
  #E;
  #o;
  #s;
  #e;
  #f;
  #p;
  #u;
  #l;
  #$;
  #c;
  #y;
  #v;
  #d;
  #w;
  #_;
  #h;
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(e) {
    return {
      // properties
      starts: e.#v,
      ttls: e.#d,
      sizes: e.#y,
      keyMap: e.#o,
      keyList: e.#s,
      valList: e.#e,
      next: e.#f,
      prev: e.#p,
      get head() {
        return e.#u;
      },
      get tail() {
        return e.#l;
      },
      free: e.#$,
      // methods
      isBackgroundFetch: (r) => e.#n(r),
      backgroundFetch: (r, n, i, s) => e.#N(r, n, i, s),
      moveToTail: (r) => e.#T(r),
      indexes: (r) => e.#A(r),
      rindexes: (r) => e.#b(r),
      isStale: (r) => e.#g(r)
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return this.#r;
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return this.#i;
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return this.#E;
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return this.#a;
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return this.#I;
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return this.#t;
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return this.#m;
  }
  constructor(e) {
    const { max: r = 0, ttl: n, ttlResolution: i = 1, ttlAutopurge: s, updateAgeOnGet: o, updateAgeOnHas: l, allowStale: a, dispose: c, disposeAfter: u, noDisposeOnSet: f, noUpdateTTL: d, maxSize: p = 0, maxEntrySize: y = 0, sizeCalculation: E, fetchMethod: w, noDeleteOnFetchRejection: $, noDeleteOnStaleGet: _, allowStaleOnFetchRejection: G, allowStaleOnFetchAbort: C, ignoreFetchAbort: D } = e;
    if (r !== 0 && !we(r))
      throw new TypeError("max option must be a nonnegative integer");
    const j = r ? hs(r) : Array;
    if (!j)
      throw new Error("invalid max value: " + r);
    if (this.#r = r, this.#i = p, this.maxEntrySize = y || this.#i, this.sizeCalculation = E, this.sizeCalculation) {
      if (!this.#i && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (w !== void 0 && typeof w != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (this.#I = w, this.#_ = !!w, this.#o = /* @__PURE__ */ new Map(), this.#s = new Array(r).fill(void 0), this.#e = new Array(r).fill(void 0), this.#f = new j(r), this.#p = new j(r), this.#u = 0, this.#l = 0, this.#$ = je.create(r), this.#a = 0, this.#E = 0, typeof c == "function" && (this.#t = c), typeof u == "function" ? (this.#m = u, this.#c = []) : (this.#m = void 0, this.#c = void 0), this.#w = !!this.#t, this.#h = !!this.#m, this.noDisposeOnSet = !!f, this.noUpdateTTL = !!d, this.noDeleteOnFetchRejection = !!$, this.allowStaleOnFetchRejection = !!G, this.allowStaleOnFetchAbort = !!C, this.ignoreFetchAbort = !!D, this.maxEntrySize !== 0) {
      if (this.#i !== 0 && !we(this.#i))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!we(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      this.#F();
    }
    if (this.allowStale = !!a, this.noDeleteOnStaleGet = !!_, this.updateAgeOnGet = !!o, this.updateAgeOnHas = !!l, this.ttlResolution = we(i) || i === 0 ? i : 1, this.ttlAutopurge = !!s, this.ttl = n || 0, this.ttl) {
      if (!we(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      this.#L();
    }
    if (this.#r === 0 && this.ttl === 0 && this.#i === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !this.#r && !this.#i) {
      const x = "LRU_CACHE_UNBOUNDED";
      $l(x) && (us.add(x), fs("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", x, ps));
    }
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(e) {
    return this.#o.has(e) ? 1 / 0 : 0;
  }
  #L() {
    const e = new ft(this.#r), r = new ft(this.#r);
    this.#d = e, this.#v = r, this.#D = (s, o, l = Le.now()) => {
      if (r[s] = o !== 0 ? l : 0, e[s] = o, o !== 0 && this.ttlAutopurge) {
        const a = setTimeout(() => {
          this.#g(s) && this.delete(this.#s[s]);
        }, o + 1);
        a.unref && a.unref();
      }
    }, this.#S = (s) => {
      r[s] = e[s] !== 0 ? Le.now() : 0;
    }, this.#R = (s, o) => {
      if (e[o]) {
        const l = e[o], a = r[o];
        if (!l || !a)
          return;
        s.ttl = l, s.start = a, s.now = n || i();
        const c = s.now - a;
        s.remainingTTL = l - c;
      }
    };
    let n = 0;
    const i = () => {
      const s = Le.now();
      if (this.ttlResolution > 0) {
        n = s;
        const o = setTimeout(() => n = 0, this.ttlResolution);
        o.unref && o.unref();
      }
      return s;
    };
    this.getRemainingTTL = (s) => {
      const o = this.#o.get(s);
      if (o === void 0)
        return 0;
      const l = e[o], a = r[o];
      if (!l || !a)
        return 1 / 0;
      const c = (n || i()) - a;
      return l - c;
    }, this.#g = (s) => {
      const o = r[s], l = e[s];
      return !!l && !!o && (n || i()) - o > l;
    };
  }
  // conditionally set private methods related to TTL
  #S = () => {
  };
  #R = () => {
  };
  #D = () => {
  };
  /* c8 ignore stop */
  #g = () => !1;
  #F() {
    const e = new ft(this.#r);
    this.#E = 0, this.#y = e, this.#O = (r) => {
      this.#E -= e[r], e[r] = 0;
    }, this.#P = (r, n, i, s) => {
      if (this.#n(n))
        return 0;
      if (!we(i))
        if (s) {
          if (typeof s != "function")
            throw new TypeError("sizeCalculation must be a function");
          if (i = s(n, r), !we(i))
            throw new TypeError("sizeCalculation return invalid (expect positive integer)");
        } else
          throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
      return i;
    }, this.#x = (r, n, i) => {
      if (e[r] = n, this.#i) {
        const s = this.#i - e[r];
        for (; this.#E > s; )
          this.#C(!0);
      }
      this.#E += e[r], i && (i.entrySize = n, i.totalCalculatedSize = this.#E);
    };
  }
  #O = (e) => {
  };
  #x = (e, r, n) => {
  };
  #P = (e, r, n, i) => {
    if (n || i)
      throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
    return 0;
  };
  *#A({ allowStale: e = this.allowStale } = {}) {
    if (this.#a)
      for (let r = this.#l; !(!this.#j(r) || ((e || !this.#g(r)) && (yield r), r === this.#u)); )
        r = this.#p[r];
  }
  *#b({ allowStale: e = this.allowStale } = {}) {
    if (this.#a)
      for (let r = this.#u; !(!this.#j(r) || ((e || !this.#g(r)) && (yield r), r === this.#l)); )
        r = this.#f[r];
  }
  #j(e) {
    return e !== void 0 && this.#o.get(this.#s[e]) === e;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const e of this.#A())
      this.#e[e] !== void 0 && this.#s[e] !== void 0 && !this.#n(this.#e[e]) && (yield [this.#s[e], this.#e[e]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const e of this.#b())
      this.#e[e] !== void 0 && this.#s[e] !== void 0 && !this.#n(this.#e[e]) && (yield [this.#s[e], this.#e[e]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const e of this.#A()) {
      const r = this.#s[e];
      r !== void 0 && !this.#n(this.#e[e]) && (yield r);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const e of this.#b()) {
      const r = this.#s[e];
      r !== void 0 && !this.#n(this.#e[e]) && (yield r);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const e of this.#A())
      this.#e[e] !== void 0 && !this.#n(this.#e[e]) && (yield this.#e[e]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const e of this.#b())
      this.#e[e] !== void 0 && !this.#n(this.#e[e]) && (yield this.#e[e]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * A String value that is used in the creation of the default string description of an object.
   * Called by the built-in method Object.prototype.toString.
   */
  [Symbol.toStringTag] = "LRUCache";
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(e, r = {}) {
    for (const n of this.#A()) {
      const i = this.#e[n], s = this.#n(i) ? i.__staleWhileFetching : i;
      if (s !== void 0 && e(s, this.#s[n], this))
        return this.get(this.#s[n], r);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(e, r = this) {
    for (const n of this.#A()) {
      const i = this.#e[n], s = this.#n(i) ? i.__staleWhileFetching : i;
      s !== void 0 && e.call(r, s, this.#s[n], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(e, r = this) {
    for (const n of this.#b()) {
      const i = this.#e[n], s = this.#n(i) ? i.__staleWhileFetching : i;
      s !== void 0 && e.call(r, s, this.#s[n], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let e = !1;
    for (const r of this.#b({ allowStale: !0 }))
      this.#g(r) && (this.delete(this.#s[r]), e = !0);
    return e;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
   * single key. Always returns stale values, if their info is found in the
   * cache, so be sure to check for expired TTLs if relevant.
   */
  info(e) {
    const r = this.#o.get(e);
    if (r === void 0)
      return;
    const n = this.#e[r], i = this.#n(n) ? n.__staleWhileFetching : n;
    if (i === void 0)
      return;
    const s = { value: i };
    if (this.#d && this.#v) {
      const o = this.#d[r], l = this.#v[r];
      if (o && l) {
        const a = o - (Le.now() - l);
        s.ttl = a, s.start = Date.now();
      }
    }
    return this.#y && (s.size = this.#y[r]), s;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const e = [];
    for (const r of this.#A({ allowStale: !0 })) {
      const n = this.#s[r], i = this.#e[r], s = this.#n(i) ? i.__staleWhileFetching : i;
      if (s === void 0 || n === void 0)
        continue;
      const o = { value: s };
      if (this.#d && this.#v) {
        o.ttl = this.#d[r];
        const l = Le.now() - this.#v[r];
        o.start = Math.floor(Date.now() - l);
      }
      this.#y && (o.size = this.#y[r]), e.unshift([n, o]);
    }
    return e;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(e) {
    this.clear();
    for (const [r, n] of e) {
      if (n.start) {
        const i = Date.now() - n.start;
        n.start = Le.now() - i;
      }
      this.set(r, n.value, n);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(e, r, n = {}) {
    if (r === void 0)
      return this.delete(e), this;
    const { ttl: i = this.ttl, start: s, noDisposeOnSet: o = this.noDisposeOnSet, sizeCalculation: l = this.sizeCalculation, status: a } = n;
    let { noUpdateTTL: c = this.noUpdateTTL } = n;
    const u = this.#P(e, r, n.size || 0, l);
    if (this.maxEntrySize && u > this.maxEntrySize)
      return a && (a.set = "miss", a.maxEntrySizeExceeded = !0), this.delete(e), this;
    let f = this.#a === 0 ? void 0 : this.#o.get(e);
    if (f === void 0)
      f = this.#a === 0 ? this.#l : this.#$.length !== 0 ? this.#$.pop() : this.#a === this.#r ? this.#C(!1) : this.#a, this.#s[f] = e, this.#e[f] = r, this.#o.set(e, f), this.#f[this.#l] = f, this.#p[f] = this.#l, this.#l = f, this.#a++, this.#x(f, u, a), a && (a.set = "add"), c = !1;
    else {
      this.#T(f);
      const d = this.#e[f];
      if (r !== d) {
        if (this.#_ && this.#n(d)) {
          d.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: p } = d;
          p !== void 0 && !o && (this.#w && this.#t?.(p, e, "set"), this.#h && this.#c?.push([p, e, "set"]));
        } else
          o || (this.#w && this.#t?.(d, e, "set"), this.#h && this.#c?.push([d, e, "set"]));
        if (this.#O(f), this.#x(f, u, a), this.#e[f] = r, a) {
          a.set = "replace";
          const p = d && this.#n(d) ? d.__staleWhileFetching : d;
          p !== void 0 && (a.oldValue = p);
        }
      } else
        a && (a.set = "update");
    }
    if (i !== 0 && !this.#d && this.#L(), this.#d && (c || this.#D(f, i, s), a && this.#R(a, f)), !o && this.#h && this.#c) {
      const d = this.#c;
      let p;
      for (; p = d?.shift(); )
        this.#m?.(...p);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    try {
      for (; this.#a; ) {
        const e = this.#e[this.#u];
        if (this.#C(!0), this.#n(e)) {
          if (e.__staleWhileFetching)
            return e.__staleWhileFetching;
        } else if (e !== void 0)
          return e;
      }
    } finally {
      if (this.#h && this.#c) {
        const e = this.#c;
        let r;
        for (; r = e?.shift(); )
          this.#m?.(...r);
      }
    }
  }
  #C(e) {
    const r = this.#u, n = this.#s[r], i = this.#e[r];
    return this.#_ && this.#n(i) ? i.__abortController.abort(new Error("evicted")) : (this.#w || this.#h) && (this.#w && this.#t?.(i, n, "evict"), this.#h && this.#c?.push([i, n, "evict"])), this.#O(r), e && (this.#s[r] = void 0, this.#e[r] = void 0, this.#$.push(r)), this.#a === 1 ? (this.#u = this.#l = 0, this.#$.length = 0) : this.#u = this.#f[r], this.#o.delete(n), this.#a--, r;
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(e, r = {}) {
    const { updateAgeOnHas: n = this.updateAgeOnHas, status: i } = r, s = this.#o.get(e);
    if (s !== void 0) {
      const o = this.#e[s];
      if (this.#n(o) && o.__staleWhileFetching === void 0)
        return !1;
      if (this.#g(s))
        i && (i.has = "stale", this.#R(i, s));
      else
        return n && this.#S(s), i && (i.has = "hit", this.#R(i, s)), !0;
    } else
      i && (i.has = "miss");
    return !1;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(e, r = {}) {
    const { allowStale: n = this.allowStale } = r, i = this.#o.get(e);
    if (i === void 0 || !n && this.#g(i))
      return;
    const s = this.#e[i];
    return this.#n(s) ? s.__staleWhileFetching : s;
  }
  #N(e, r, n, i) {
    const s = r === void 0 ? void 0 : this.#e[r];
    if (this.#n(s))
      return s;
    const o = new pt(), { signal: l } = n;
    l?.addEventListener("abort", () => o.abort(l.reason), {
      signal: o.signal
    });
    const a = {
      signal: o.signal,
      options: n,
      context: i
    }, c = (E, w = !1) => {
      const { aborted: $ } = o.signal, _ = n.ignoreFetchAbort && E !== void 0;
      if (n.status && ($ && !w ? (n.status.fetchAborted = !0, n.status.fetchError = o.signal.reason, _ && (n.status.fetchAbortIgnored = !0)) : n.status.fetchResolved = !0), $ && !_ && !w)
        return f(o.signal.reason);
      const G = p;
      return this.#e[r] === p && (E === void 0 ? G.__staleWhileFetching ? this.#e[r] = G.__staleWhileFetching : this.delete(e) : (n.status && (n.status.fetchUpdated = !0), this.set(e, E, a.options))), E;
    }, u = (E) => (n.status && (n.status.fetchRejected = !0, n.status.fetchError = E), f(E)), f = (E) => {
      const { aborted: w } = o.signal, $ = w && n.allowStaleOnFetchAbort, _ = $ || n.allowStaleOnFetchRejection, G = _ || n.noDeleteOnFetchRejection, C = p;
      if (this.#e[r] === p && (!G || C.__staleWhileFetching === void 0 ? this.delete(e) : $ || (this.#e[r] = C.__staleWhileFetching)), _)
        return n.status && C.__staleWhileFetching !== void 0 && (n.status.returnedStale = !0), C.__staleWhileFetching;
      if (C.__returned === C)
        throw E;
    }, d = (E, w) => {
      const $ = this.#I?.(e, s, a);
      $ && $ instanceof Promise && $.then((_) => E(_ === void 0 ? void 0 : _), w), o.signal.addEventListener("abort", () => {
        (!n.ignoreFetchAbort || n.allowStaleOnFetchAbort) && (E(void 0), n.allowStaleOnFetchAbort && (E = (_) => c(_, !0)));
      });
    };
    n.status && (n.status.fetchDispatched = !0);
    const p = new Promise(d).then(c, u), y = Object.assign(p, {
      __abortController: o,
      __staleWhileFetching: s,
      __returned: void 0
    });
    return r === void 0 ? (this.set(e, y, { ...a.options, status: void 0 }), r = this.#o.get(e)) : this.#e[r] = y, y;
  }
  #n(e) {
    if (!this.#_)
      return !1;
    const r = e;
    return !!r && r instanceof Promise && r.hasOwnProperty("__staleWhileFetching") && r.__abortController instanceof pt;
  }
  async fetch(e, r = {}) {
    const {
      // get options
      allowStale: n = this.allowStale,
      updateAgeOnGet: i = this.updateAgeOnGet,
      noDeleteOnStaleGet: s = this.noDeleteOnStaleGet,
      // set options
      ttl: o = this.ttl,
      noDisposeOnSet: l = this.noDisposeOnSet,
      size: a = 0,
      sizeCalculation: c = this.sizeCalculation,
      noUpdateTTL: u = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: f = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: d = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: p = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: y = this.allowStaleOnFetchAbort,
      context: E,
      forceRefresh: w = !1,
      status: $,
      signal: _
    } = r;
    if (!this.#_)
      return $ && ($.fetch = "get"), this.get(e, {
        allowStale: n,
        updateAgeOnGet: i,
        noDeleteOnStaleGet: s,
        status: $
      });
    const G = {
      allowStale: n,
      updateAgeOnGet: i,
      noDeleteOnStaleGet: s,
      ttl: o,
      noDisposeOnSet: l,
      size: a,
      sizeCalculation: c,
      noUpdateTTL: u,
      noDeleteOnFetchRejection: f,
      allowStaleOnFetchRejection: d,
      allowStaleOnFetchAbort: y,
      ignoreFetchAbort: p,
      status: $,
      signal: _
    };
    let C = this.#o.get(e);
    if (C === void 0) {
      $ && ($.fetch = "miss");
      const D = this.#N(e, C, G, E);
      return D.__returned = D;
    } else {
      const D = this.#e[C];
      if (this.#n(D)) {
        const m = n && D.__staleWhileFetching !== void 0;
        return $ && ($.fetch = "inflight", m && ($.returnedStale = !0)), m ? D.__staleWhileFetching : D.__returned = D;
      }
      const j = this.#g(C);
      if (!w && !j)
        return $ && ($.fetch = "hit"), this.#T(C), i && this.#S(C), $ && this.#R($, C), D;
      const x = this.#N(e, C, G, E), L = x.__staleWhileFetching !== void 0 && n;
      return $ && ($.fetch = j ? "stale" : "refresh", L && j && ($.returnedStale = !0)), L ? x.__staleWhileFetching : x.__returned = x;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(e, r = {}) {
    const { allowStale: n = this.allowStale, updateAgeOnGet: i = this.updateAgeOnGet, noDeleteOnStaleGet: s = this.noDeleteOnStaleGet, status: o } = r, l = this.#o.get(e);
    if (l !== void 0) {
      const a = this.#e[l], c = this.#n(a);
      return o && this.#R(o, l), this.#g(l) ? (o && (o.get = "stale"), c ? (o && n && a.__staleWhileFetching !== void 0 && (o.returnedStale = !0), n ? a.__staleWhileFetching : void 0) : (s || this.delete(e), o && n && (o.returnedStale = !0), n ? a : void 0)) : (o && (o.get = "hit"), c ? a.__staleWhileFetching : (this.#T(l), i && this.#S(l), a));
    } else
      o && (o.get = "miss");
  }
  #H(e, r) {
    this.#p[r] = e, this.#f[e] = r;
  }
  #T(e) {
    e !== this.#l && (e === this.#u ? this.#u = this.#f[e] : this.#H(this.#p[e], this.#f[e]), this.#H(this.#l, e), this.#l = e);
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(e) {
    let r = !1;
    if (this.#a !== 0) {
      const n = this.#o.get(e);
      if (n !== void 0)
        if (r = !0, this.#a === 1)
          this.clear();
        else {
          this.#O(n);
          const i = this.#e[n];
          if (this.#n(i) ? i.__abortController.abort(new Error("deleted")) : (this.#w || this.#h) && (this.#w && this.#t?.(i, e, "delete"), this.#h && this.#c?.push([i, e, "delete"])), this.#o.delete(e), this.#s[n] = void 0, this.#e[n] = void 0, n === this.#l)
            this.#l = this.#p[n];
          else if (n === this.#u)
            this.#u = this.#f[n];
          else {
            const s = this.#p[n];
            this.#f[s] = this.#f[n];
            const o = this.#f[n];
            this.#p[o] = this.#p[n];
          }
          this.#a--, this.#$.push(n);
        }
    }
    if (this.#h && this.#c?.length) {
      const n = this.#c;
      let i;
      for (; i = n?.shift(); )
        this.#m?.(...i);
    }
    return r;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    for (const e of this.#b({ allowStale: !0 })) {
      const r = this.#e[e];
      if (this.#n(r))
        r.__abortController.abort(new Error("deleted"));
      else {
        const n = this.#s[e];
        this.#w && this.#t?.(r, n, "delete"), this.#h && this.#c?.push([r, n, "delete"]);
      }
    }
    if (this.#o.clear(), this.#e.fill(void 0), this.#s.fill(void 0), this.#d && this.#v && (this.#d.fill(0), this.#v.fill(0)), this.#y && this.#y.fill(0), this.#u = 0, this.#l = 0, this.#$.length = 0, this.#E = 0, this.#a = 0, this.#h && this.#c) {
      const e = this.#c;
      let r;
      for (; r = e?.shift(); )
        this.#m?.(...r);
    }
  }
};
_t.LRUCache = yl;
const B = (...t) => t.every((e) => e) ? t.join("") : "", Y = (t) => t ? encodeURIComponent(t) : "", ds = (t) => t.toLowerCase().replace(/^\W+|\/|\W+$/g, "").replace(/\W+/g, "-"), vl = {
  sshtemplate: ({ domain: t, user: e, project: r, committish: n }) => `git@${t}:${e}/${r}.git${B("#", n)}`,
  sshurltemplate: ({ domain: t, user: e, project: r, committish: n }) => `git+ssh://git@${t}/${e}/${r}.git${B("#", n)}`,
  edittemplate: ({ domain: t, user: e, project: r, committish: n, editpath: i, path: s }) => `https://${t}/${e}/${r}${B("/", i, "/", Y(n || "HEAD"), "/", s)}`,
  browsetemplate: ({ domain: t, user: e, project: r, committish: n, treepath: i }) => `https://${t}/${e}/${r}${B("/", i, "/", Y(n))}`,
  browsetreetemplate: ({ domain: t, user: e, project: r, committish: n, treepath: i, path: s, fragment: o, hashformat: l }) => `https://${t}/${e}/${r}/${i}/${Y(n || "HEAD")}/${s}${B("#", l(o || ""))}`,
  browseblobtemplate: ({ domain: t, user: e, project: r, committish: n, blobpath: i, path: s, fragment: o, hashformat: l }) => `https://${t}/${e}/${r}/${i}/${Y(n || "HEAD")}/${s}${B("#", l(o || ""))}`,
  docstemplate: ({ domain: t, user: e, project: r, treepath: n, committish: i }) => `https://${t}/${e}/${r}${B("/", n, "/", Y(i))}#readme`,
  httpstemplate: ({ auth: t, domain: e, user: r, project: n, committish: i }) => `git+https://${B(t, "@")}${e}/${r}/${n}.git${B("#", i)}`,
  filetemplate: ({ domain: t, user: e, project: r, committish: n, path: i }) => `https://${t}/${e}/${r}/raw/${Y(n || "HEAD")}/${i}`,
  shortcuttemplate: ({ type: t, user: e, project: r, committish: n }) => `${t}:${e}/${r}${B("#", n)}`,
  pathtemplate: ({ user: t, project: e, committish: r }) => `${t}/${e}${B("#", r)}`,
  bugstemplate: ({ domain: t, user: e, project: r }) => `https://${t}/${e}/${r}/issues`,
  hashformat: ds
}, Ae = {};
Ae.github = {
  // First two are insecure and generally shouldn't be used any more, but
  // they are still supported.
  protocols: ["git:", "http:", "git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "github.com",
  treepath: "tree",
  blobpath: "blob",
  editpath: "edit",
  filetemplate: ({ auth: t, user: e, project: r, committish: n, path: i }) => `https://${B(t, "@")}raw.githubusercontent.com/${e}/${r}/${Y(n || "HEAD")}/${i}`,
  gittemplate: ({ auth: t, domain: e, user: r, project: n, committish: i }) => `git://${B(t, "@")}${e}/${r}/${n}.git${B("#", i)}`,
  tarballtemplate: ({ domain: t, user: e, project: r, committish: n }) => `https://codeload.${t}/${e}/${r}/tar.gz/${Y(n || "HEAD")}`,
  extract: (t) => {
    let [, e, r, n, i] = t.pathname.split("/", 5);
    if (!(n && n !== "tree") && (n || (i = t.hash.slice(1)), r && r.endsWith(".git") && (r = r.slice(0, -4)), !(!e || !r)))
      return { user: e, project: r, committish: i };
  }
};
Ae.bitbucket = {
  protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "bitbucket.org",
  treepath: "src",
  blobpath: "src",
  editpath: "?mode=edit",
  edittemplate: ({ domain: t, user: e, project: r, committish: n, treepath: i, path: s, editpath: o }) => `https://${t}/${e}/${r}${B("/", i, "/", Y(n || "HEAD"), "/", s, o)}`,
  tarballtemplate: ({ domain: t, user: e, project: r, committish: n }) => `https://${t}/${e}/${r}/get/${Y(n || "HEAD")}.tar.gz`,
  extract: (t) => {
    let [, e, r, n] = t.pathname.split("/", 4);
    if (!["get"].includes(n) && (r && r.endsWith(".git") && (r = r.slice(0, -4)), !(!e || !r)))
      return { user: e, project: r, committish: t.hash.slice(1) };
  }
};
Ae.gitlab = {
  protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "gitlab.com",
  treepath: "tree",
  blobpath: "tree",
  editpath: "-/edit",
  httpstemplate: ({ auth: t, domain: e, user: r, project: n, committish: i }) => `git+https://${B(t, "@")}${e}/${r}/${n}.git${B("#", i)}`,
  tarballtemplate: ({ domain: t, user: e, project: r, committish: n }) => `https://${t}/${e}/${r}/repository/archive.tar.gz?ref=${Y(n || "HEAD")}`,
  extract: (t) => {
    const e = t.pathname.slice(1);
    if (e.includes("/-/") || e.includes("/archive.tar.gz"))
      return;
    const r = e.split("/");
    let n = r.pop();
    n.endsWith(".git") && (n = n.slice(0, -4));
    const i = r.join("/");
    if (!(!i || !n))
      return { user: i, project: n, committish: t.hash.slice(1) };
  }
};
Ae.gist = {
  protocols: ["git:", "git+ssh:", "git+https:", "ssh:", "https:"],
  domain: "gist.github.com",
  editpath: "edit",
  sshtemplate: ({ domain: t, project: e, committish: r }) => `git@${t}:${e}.git${B("#", r)}`,
  sshurltemplate: ({ domain: t, project: e, committish: r }) => `git+ssh://git@${t}/${e}.git${B("#", r)}`,
  edittemplate: ({ domain: t, user: e, project: r, committish: n, editpath: i }) => `https://${t}/${e}/${r}${B("/", Y(n))}/${i}`,
  browsetemplate: ({ domain: t, project: e, committish: r }) => `https://${t}/${e}${B("/", Y(r))}`,
  browsetreetemplate: ({ domain: t, project: e, committish: r, path: n, hashformat: i }) => `https://${t}/${e}${B("/", Y(r))}${B("#", i(n))}`,
  browseblobtemplate: ({ domain: t, project: e, committish: r, path: n, hashformat: i }) => `https://${t}/${e}${B("/", Y(r))}${B("#", i(n))}`,
  docstemplate: ({ domain: t, project: e, committish: r }) => `https://${t}/${e}${B("/", Y(r))}`,
  httpstemplate: ({ domain: t, project: e, committish: r }) => `git+https://${t}/${e}.git${B("#", r)}`,
  filetemplate: ({ user: t, project: e, committish: r, path: n }) => `https://gist.githubusercontent.com/${t}/${e}/raw${B("/", Y(r))}/${n}`,
  shortcuttemplate: ({ type: t, project: e, committish: r }) => `${t}:${e}${B("#", r)}`,
  pathtemplate: ({ project: t, committish: e }) => `${t}${B("#", e)}`,
  bugstemplate: ({ domain: t, project: e }) => `https://${t}/${e}`,
  gittemplate: ({ domain: t, project: e, committish: r }) => `git://${t}/${e}.git${B("#", r)}`,
  tarballtemplate: ({ project: t, committish: e }) => `https://codeload.github.com/gist/${t}/tar.gz/${Y(e || "HEAD")}`,
  extract: (t) => {
    let [, e, r, n] = t.pathname.split("/", 4);
    if (n !== "raw") {
      if (!r) {
        if (!e)
          return;
        r = e, e = null;
      }
      return r.endsWith(".git") && (r = r.slice(0, -4)), { user: e, project: r, committish: t.hash.slice(1) };
    }
  },
  hashformat: function(t) {
    return t && "file-" + ds(t);
  }
};
Ae.sourcehut = {
  protocols: ["git+ssh:", "https:"],
  domain: "git.sr.ht",
  treepath: "tree",
  blobpath: "tree",
  filetemplate: ({ domain: t, user: e, project: r, committish: n, path: i }) => `https://${t}/${e}/${r}/blob/${Y(n) || "HEAD"}/${i}`,
  httpstemplate: ({ domain: t, user: e, project: r, committish: n }) => `https://${t}/${e}/${r}.git${B("#", n)}`,
  tarballtemplate: ({ domain: t, user: e, project: r, committish: n }) => `https://${t}/${e}/${r}/archive/${Y(n) || "HEAD"}.tar.gz`,
  bugstemplate: () => null,
  extract: (t) => {
    let [, e, r, n] = t.pathname.split("/", 4);
    if (!["archive"].includes(n) && (r && r.endsWith(".git") && (r = r.slice(0, -4)), !(!e || !r)))
      return { user: e, project: r, committish: t.hash.slice(1) };
  }
};
for (const [t, e] of Object.entries(Ae))
  Ae[t] = Object.assign({}, vl, e);
var wl = Ae;
const Al = Zn, Wt = (t, e, r) => {
  const n = t.indexOf(r);
  return t.lastIndexOf(e, n > -1 ? n : 1 / 0);
}, vn = (t) => {
  try {
    return new Al.URL(t);
  } catch {
  }
}, bl = (t, e) => {
  const r = t.indexOf(":"), n = t.slice(0, r + 1);
  if (Object.prototype.hasOwnProperty.call(e, n))
    return t;
  const i = t.indexOf("@");
  return i > -1 ? i > r ? `git+ssh://${t}` : t : t.indexOf("//") === r + 1 ? t : `${t.slice(0, r + 1)}//${t.slice(r + 1)}`;
}, Rl = (t) => {
  const e = Wt(t, "@", "#"), r = Wt(t, ":", "#");
  return r > e && (t = t.slice(0, r) + "/" + t.slice(r + 1)), Wt(t, ":", "#") === -1 && t.indexOf("//") === -1 && (t = `git+ssh://${t}`), t;
};
var gs = (t, e) => {
  const r = e ? bl(t, e) : t;
  return vn(r) || vn(Rl(r));
};
const _l = gs, Sl = (t) => {
  const e = t.indexOf("#"), r = t.indexOf("/"), n = t.indexOf("/", r + 1), i = t.indexOf(":"), s = /\s/.exec(t), o = t.indexOf("@"), l = !s || e > -1 && s.index > e, a = o === -1 || e > -1 && o > e, c = i === -1 || e > -1 && i > e, u = n === -1 || e > -1 && n > e, f = r > 0, d = e > -1 ? t[e - 1] !== "/" : !t.endsWith("/"), p = !t.startsWith(".");
  return l && f && d && p && a && c && u;
};
var Ol = (t, e, { gitHosts: r, protocols: n }) => {
  if (!t)
    return;
  const i = Sl(t) ? `github:${t}` : t, s = _l(i, n);
  if (!s)
    return;
  const o = r.byShortcut[s.protocol], l = r.byDomain[s.hostname.startsWith("www.") ? s.hostname.slice(4) : s.hostname], a = o || l;
  if (!a)
    return;
  const c = r[o || l];
  let u = null;
  n[s.protocol]?.auth && (s.username || s.password) && (u = `${s.username}${s.password ? ":" + s.password : ""}`);
  let f = null, d = null, p = null, y = null;
  try {
    if (o) {
      let E = s.pathname.startsWith("/") ? s.pathname.slice(1) : s.pathname;
      const w = E.indexOf("@");
      w > -1 && (E = E.slice(w + 1));
      const $ = E.lastIndexOf("/");
      $ > -1 ? (d = decodeURIComponent(E.slice(0, $)), d || (d = null), p = decodeURIComponent(E.slice($ + 1))) : p = decodeURIComponent(E), p.endsWith(".git") && (p = p.slice(0, -4)), s.hash && (f = decodeURIComponent(s.hash.slice(1))), y = "shortcut";
    } else {
      if (!c.protocols.includes(s.protocol))
        return;
      const E = c.extract(s);
      if (!E)
        return;
      d = E.user && decodeURIComponent(E.user), p = decodeURIComponent(E.project), f = decodeURIComponent(E.committish), y = n[s.protocol]?.name || s.protocol.slice(0, -1);
    }
  } catch (E) {
    if (E instanceof URIError)
      return;
    throw E;
  }
  return [a, d, u, p, f, y, e];
};
const { LRUCache: Tl } = _t, Il = wl, xl = Ol, Cl = gs, Xt = new Tl({ max: 1e3 });
class ae {
  constructor(e, r, n, i, s, o, l = {}) {
    Object.assign(this, ae.#r[e], {
      type: e,
      user: r,
      auth: n,
      project: i,
      committish: s,
      default: o,
      opts: l
    });
  }
  static #r = { byShortcut: {}, byDomain: {} };
  static #i = {
    "git+ssh:": { name: "sshurl" },
    "ssh:": { name: "sshurl" },
    "git+https:": { name: "https", auth: !0 },
    "git:": { auth: !0 },
    "http:": { auth: !0 },
    "https:": { auth: !0 },
    "git+http:": { auth: !0 }
  };
  static addHost(e, r) {
    ae.#r[e] = r, ae.#r.byDomain[r.domain] = e, ae.#r.byShortcut[`${e}:`] = e, ae.#i[`${e}:`] = { name: e };
  }
  static fromUrl(e, r) {
    if (typeof e != "string")
      return;
    const n = e + JSON.stringify(r || {});
    if (!Xt.has(n)) {
      const i = xl(e, r, {
        gitHosts: ae.#r,
        protocols: ae.#i
      });
      Xt.set(n, i ? new ae(...i) : void 0);
    }
    return Xt.get(n);
  }
  static parseUrl(e) {
    return Cl(e);
  }
  #t(e, r) {
    if (typeof e != "function")
      return null;
    const n = { ...this, ...this.opts, ...r };
    n.path || (n.path = ""), n.path.startsWith("/") && (n.path = n.path.slice(1)), n.noCommittish && (n.committish = null);
    const i = e(n);
    return n.noGitPlus && i.startsWith("git+") ? i.slice(4) : i;
  }
  hash() {
    return this.committish ? `#${this.committish}` : "";
  }
  ssh(e) {
    return this.#t(this.sshtemplate, e);
  }
  sshurl(e) {
    return this.#t(this.sshurltemplate, e);
  }
  browse(e, ...r) {
    return typeof e != "string" ? this.#t(this.browsetemplate, e) : typeof r[0] != "string" ? this.#t(this.browsetreetemplate, { ...r[0], path: e }) : this.#t(this.browsetreetemplate, { ...r[1], fragment: r[0], path: e });
  }
  // If the path is known to be a file, then browseFile should be used. For some hosts
  // the url is the same as browse, but for others like GitHub a file can use both `/tree/`
  // and `/blob/` in the path. When using a default committish of `HEAD` then the `/tree/`
  // path will redirect to a specific commit. Using the `/blob/` path avoids this and
  // does not redirect to a different commit.
  browseFile(e, ...r) {
    return typeof r[0] != "string" ? this.#t(this.browseblobtemplate, { ...r[0], path: e }) : this.#t(this.browseblobtemplate, { ...r[1], fragment: r[0], path: e });
  }
  docs(e) {
    return this.#t(this.docstemplate, e);
  }
  bugs(e) {
    return this.#t(this.bugstemplate, e);
  }
  https(e) {
    return this.#t(this.httpstemplate, e);
  }
  git(e) {
    return this.#t(this.gittemplate, e);
  }
  shortcut(e) {
    return this.#t(this.shortcuttemplate, e);
  }
  path(e) {
    return this.#t(this.pathtemplate, e);
  }
  tarball(e) {
    return this.#t(this.tarballtemplate, { ...e, noCommittish: !1 });
  }
  file(e, r) {
    return this.#t(this.filetemplate, { ...r, path: e });
  }
  edit(e, r) {
    return this.#t(this.edittemplate, { ...r, path: e });
  }
  getDefaultRepresentation() {
    return this.default;
  }
  toString(e) {
    return this.default && typeof this[this.default] == "function" ? this[this.default](e) : this.sshurl(e);
  }
}
for (const [t, e] of Object.entries(Il))
  ae.addHost(t, e);
var Nl = ae;
const Ll = /* @__PURE__ */ Ge(Nl), Dl = [
  [1e3, 6e4, "sec"],
  [6e4, 36e5, "min"],
  [36e5, 864e5, "hour"],
  [864e5, 6048e5, "day"],
  [6048e5, 2628e6, "week"],
  [2628e6, 31536e6, "month"],
  [31536e6, 1 / 0, "year"]
], Pl = {
  "1 day ago": "yesterday",
  "1 week ago": "last week",
  "1 month ago": "last month",
  "1 year ago": "last year",
  "in 1 day": "tomorrow",
  "in 1 week": "next week",
  "in 1 month": "next month",
  "in 1 year": "next year"
}, jl = {
  sec: "second",
  min: "minute"
};
function wn(t) {
  return t instanceof Date ? t.getTime() : typeof t == "string" ? Date.parse(t) : t;
}
function qt(t, { now: e, noAffix: r = !1, times: n = Dl, nowThreshold: i = 2e3, nowString: s = "now", unknownString: o = "", aliases: l = !1, aliasesMap: a = Pl, longUnits: c = !1 } = {}) {
  const u = wn(t);
  if (e = e !== void 0 ? wn(e) : Date.now(), Number.isNaN(u))
    return o || String(t);
  let f = !1, d = e - u;
  if (d < 0 && (f = !0, d = Math.abs(d)), d < i)
    return s;
  let p, y;
  for (let w = 0, $ = n.length; w < $; w++) {
    const _ = n[w];
    if (!(d >= _[1])) {
      p = Math.floor(d / _[0]), y = (c && jl[_[2]] || _[2]) + (p > 1 ? "s" : "");
      break;
    }
  }
  const E = `${f && !r ? "in " : ""}${p} ${y}${!f && !r ? " ago" : ""}`;
  return l ? a[E] ?? E : E;
}
function se(t, e = globalThis.Deno ? globalThis.Deno.args : hr.argv) {
  const r = t.startsWith("-") ? "" : t.length === 1 ? "-" : "--", n = e.indexOf(r + t), i = e.indexOf("--");
  return n !== -1 && (i === -1 || n < i);
}
const { env: q } = hr;
let dt;
se("no-color") || se("no-colors") || se("color=false") || se("color=never") ? dt = 0 : (se("color") || se("colors") || se("color=true") || se("color=always")) && (dt = 1);
function Hl() {
  if ("FORCE_COLOR" in q)
    return q.FORCE_COLOR === "true" ? 1 : q.FORCE_COLOR === "false" ? 0 : q.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(q.FORCE_COLOR, 10), 3);
}
function Fl(t) {
  return t === 0 ? !1 : {
    level: t,
    hasBasic: !0,
    has256: t >= 2,
    has16m: t >= 3
  };
}
function Gl(t, { streamIsTTY: e, sniffFlags: r = !0 } = {}) {
  const n = Hl();
  n !== void 0 && (dt = n);
  const i = r ? dt : n;
  if (i === 0)
    return 0;
  if (r) {
    if (se("color=16m") || se("color=full") || se("color=truecolor"))
      return 3;
    if (se("color=256"))
      return 2;
  }
  if ("TF_BUILD" in q && "AGENT_NAME" in q)
    return 1;
  if (t && !e && i === void 0)
    return 0;
  const s = i || 0;
  if (q.TERM === "dumb")
    return s;
  if (hr.platform === "win32") {
    const o = Ws.release().split(".");
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? Number(o[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in q)
    return "GITHUB_ACTIONS" in q || "GITEA_ACTIONS" in q ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((o) => o in q) || q.CI_NAME === "codeship" ? 1 : s;
  if ("TEAMCITY_VERSION" in q)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(q.TEAMCITY_VERSION) ? 1 : 0;
  if (q.COLORTERM === "truecolor" || q.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in q) {
    const o = Number.parseInt((q.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (q.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(q.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(q.TERM) || "COLORTERM" in q ? 1 : s;
}
function An(t, e = {}) {
  const r = Gl(t, {
    streamIsTTY: t && t.isTTY,
    ...e
  });
  return Fl(r);
}
const Ul = {
  stdout: An({ isTTY: Dr.isatty(1) }),
  stderr: An({ isTTY: Dr.isatty(2) })
};
let ms = !0;
function Ml() {
  ms = !1;
}
function wr(t, e, r) {
  const n = t.join(" ");
  return ms ? `\x1B[${e}m${n}\x1B[${r}m` : n;
}
const Ar = (...t) => wr(t, 31, 39), br = (...t) => wr(t, 32, 39), Bl = (...t) => wr(t, 35, 39), kl = (t) => {
  const e = typeof t;
  return t !== null && (e === "object" || e === "function");
}, Kt = /* @__PURE__ */ new Set([
  "__proto__",
  "prototype",
  "constructor"
]), zl = new Set("0123456789");
function Vl(t) {
  const e = [];
  let r = "", n = "start", i = !1;
  for (const s of t)
    switch (s) {
      case "\\": {
        if (n === "index")
          throw new Error("Invalid character in an index");
        if (n === "indexEnd")
          throw new Error("Invalid character after an index");
        i && (r += s), n = "property", i = !i;
        break;
      }
      case ".": {
        if (n === "index")
          throw new Error("Invalid character in an index");
        if (n === "indexEnd") {
          n = "property";
          break;
        }
        if (i) {
          i = !1, r += s;
          break;
        }
        if (Kt.has(r))
          return [];
        e.push(r), r = "", n = "property";
        break;
      }
      case "[": {
        if (n === "index")
          throw new Error("Invalid character in an index");
        if (n === "indexEnd") {
          n = "index";
          break;
        }
        if (i) {
          i = !1, r += s;
          break;
        }
        if (n === "property") {
          if (Kt.has(r))
            return [];
          e.push(r), r = "";
        }
        n = "index";
        break;
      }
      case "]": {
        if (n === "index") {
          e.push(Number.parseInt(r, 10)), r = "", n = "indexEnd";
          break;
        }
        if (n === "indexEnd")
          throw new Error("Invalid character after an index");
      }
      default: {
        if (n === "index" && !zl.has(s))
          throw new Error("Invalid character in an index");
        if (n === "indexEnd")
          throw new Error("Invalid character after an index");
        n === "start" && (n = "property"), i && (i = !1, r += "\\"), r += s;
      }
    }
  switch (i && (r += "\\"), n) {
    case "property": {
      if (Kt.has(r))
        return [];
      e.push(r);
      break;
    }
    case "index":
      throw new Error("Index was not closed");
    case "start": {
      e.push("");
      break;
    }
  }
  return e;
}
function Wl(t, e) {
  if (typeof e != "number" && Array.isArray(t)) {
    const r = Number.parseInt(e, 10);
    return Number.isInteger(r) && t[r] === t[e];
  }
  return !1;
}
function Xl(t, e, r) {
  if (!kl(t) || typeof e != "string")
    return r === void 0 ? t : r;
  const n = Vl(e);
  if (n.length === 0)
    return r;
  for (let i = 0; i < n.length; i++) {
    const s = n[i];
    if (Wl(t, s) ? t = i === n.length - 1 ? void 0 : null : t = t[s], t == null) {
      if (i !== n.length - 1)
        return r;
      break;
    }
  }
  return t === void 0 ? r : t;
}
class ql extends Error {
  constructor(e) {
    super(), this.name = "AbortError", this.message = e;
  }
}
const bn = (t) => globalThis.DOMException === void 0 ? new ql(t) : new DOMException(t), Rn = (t) => {
  const e = t.reason === void 0 ? bn("This operation was aborted.") : t.reason;
  return e instanceof Error ? e : bn(e);
};
async function Kl(t, e, {
  concurrency: r = Number.POSITIVE_INFINITY,
  stopOnError: n = !0,
  signal: i
} = {}) {
  return new Promise((s, o) => {
    if (t[Symbol.iterator] === void 0 && t[Symbol.asyncIterator] === void 0)
      throw new TypeError(`Expected \`input\` to be either an \`Iterable\` or \`AsyncIterable\`, got (${typeof t})`);
    if (typeof e != "function")
      throw new TypeError("Mapper function is required");
    if (!((Number.isSafeInteger(r) || r === Number.POSITIVE_INFINITY) && r >= 1))
      throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${r}\` (${typeof r})`);
    const l = [], a = [], c = /* @__PURE__ */ new Map();
    let u = !1, f = !1, d = !1, p = 0, y = 0;
    const E = t[Symbol.iterator] === void 0 ? t[Symbol.asyncIterator]() : t[Symbol.iterator](), w = (_) => {
      u = !0, f = !0, o(_);
    };
    i && (i.aborted && w(Rn(i)), i.addEventListener("abort", () => {
      w(Rn(i));
    }));
    const $ = async () => {
      if (f)
        return;
      const _ = await E.next(), G = y;
      if (y++, _.done) {
        if (d = !0, p === 0 && !f) {
          if (!n && a.length > 0) {
            w(new AggregateError(a));
            return;
          }
          if (f = !0, c.size === 0) {
            s(l);
            return;
          }
          const C = [];
          for (const [D, j] of l.entries())
            c.get(D) !== _n && C.push(j);
          s(C);
        }
        return;
      }
      p++, (async () => {
        try {
          const C = await _.value;
          if (f)
            return;
          const D = await e(C, G);
          D === _n && c.set(G, D), l[G] = D, p--, await $();
        } catch (C) {
          if (n)
            w(C);
          else {
            a.push(C), p--;
            try {
              await $();
            } catch (D) {
              w(D);
            }
          }
        }
      })();
    };
    (async () => {
      for (let _ = 0; _ < r; _++) {
        try {
          await $();
        } catch (G) {
          w(G);
          break;
        }
        if (d || u)
          break;
      }
    })();
  });
}
const _n = Symbol("skip");
async function Sn(t, e) {
  return Kl(t, (r) => r(), e);
}
function Ke(t, e) {
  var r = 0, n, i;
  e = e || {};
  function s() {
    var o = n, l = arguments.length, a, c;
    e:
      for (; o; ) {
        if (o.args.length !== arguments.length) {
          o = o.next;
          continue;
        }
        for (c = 0; c < l; c++)
          if (o.args[c] !== arguments[c]) {
            o = o.next;
            continue e;
          }
        return o !== n && (o === i && (i = o.prev), o.prev.next = o.next, o.next && (o.next.prev = o.prev), o.next = n, o.prev = null, n.prev = o, n = o), o.val;
      }
    for (a = new Array(l), c = 0; c < l; c++)
      a[c] = arguments[c];
    return o = {
      args: a,
      // Generate the result from original function
      val: t.apply(null, a)
    }, n ? (n.prev = o, o.next = n) : i = o, r === /** @type {MemizeOptions} */
    e.maxSize ? (i = /** @type {MemizeCacheNode} */
    i.prev, i.next = null) : r++, n = o, o.val;
  }
  return s.clear = function() {
    n = null, i = null, r = 0;
  }, s;
}
var Ye = {};
const fe = "\\\\/", On = `[^${fe}]`, Ee = "\\.", Yl = "\\+", Zl = "\\?", St = "\\/", Ql = "(?=.)", Es = "[^/]", Rr = `(?:${St}|$)`, $s = `(?:^|${St})`, _r = `${Ee}{1,2}${Rr}`, Jl = `(?!${Ee})`, ec = `(?!${$s}${_r})`, tc = `(?!${Ee}{0,1}${Rr})`, rc = `(?!${_r})`, nc = `[^.${St}]`, sc = `${Es}*?`, ic = "/", ys = {
  DOT_LITERAL: Ee,
  PLUS_LITERAL: Yl,
  QMARK_LITERAL: Zl,
  SLASH_LITERAL: St,
  ONE_CHAR: Ql,
  QMARK: Es,
  END_ANCHOR: Rr,
  DOTS_SLASH: _r,
  NO_DOT: Jl,
  NO_DOTS: ec,
  NO_DOT_SLASH: tc,
  NO_DOTS_SLASH: rc,
  QMARK_NO_DOT: nc,
  STAR: sc,
  START_ANCHOR: $s,
  SEP: ic
}, oc = {
  ...ys,
  SLASH_LITERAL: `[${fe}]`,
  QMARK: On,
  STAR: `${On}*?`,
  DOTS_SLASH: `${Ee}{1,2}(?:[${fe}]|$)`,
  NO_DOT: `(?!${Ee})`,
  NO_DOTS: `(?!(?:^|[${fe}])${Ee}{1,2}(?:[${fe}]|$))`,
  NO_DOT_SLASH: `(?!${Ee}{0,1}(?:[${fe}]|$))`,
  NO_DOTS_SLASH: `(?!${Ee}{1,2}(?:[${fe}]|$))`,
  QMARK_NO_DOT: `[^.${fe}]`,
  START_ANCHOR: `(?:^|[${fe}])`,
  END_ANCHOR: `(?:[${fe}]|$)`,
  SEP: "\\"
}, ac = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var Ot = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: ac,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(t) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${t.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(t) {
    return t === !0 ? oc : ys;
  }
};
(function(t) {
  const {
    REGEX_BACKSLASH: e,
    REGEX_REMOVE_BACKSLASH: r,
    REGEX_SPECIAL_CHARS: n,
    REGEX_SPECIAL_CHARS_GLOBAL: i
  } = Ot;
  t.isObject = (s) => s !== null && typeof s == "object" && !Array.isArray(s), t.hasRegexChars = (s) => n.test(s), t.isRegexChar = (s) => s.length === 1 && t.hasRegexChars(s), t.escapeRegex = (s) => s.replace(i, "\\$1"), t.toPosixSlashes = (s) => s.replace(e, "/"), t.isWindows = () => {
    if (typeof navigator < "u" && navigator.platform) {
      const s = navigator.platform.toLowerCase();
      return s === "win32" || s === "windows";
    }
    return typeof process < "u" && process.platform ? process.platform === "win32" : !1;
  }, t.removeBackslashes = (s) => s.replace(r, (o) => o === "\\" ? "" : o), t.escapeLast = (s, o, l) => {
    const a = s.lastIndexOf(o, l);
    return a === -1 ? s : s[a - 1] === "\\" ? t.escapeLast(s, o, a - 1) : `${s.slice(0, a)}\\${s.slice(a)}`;
  }, t.removePrefix = (s, o = {}) => {
    let l = s;
    return l.startsWith("./") && (l = l.slice(2), o.prefix = "./"), l;
  }, t.wrapOutput = (s, o = {}, l = {}) => {
    const a = l.contains ? "" : "^", c = l.contains ? "" : "$";
    let u = `${a}(?:${s})${c}`;
    return o.negated === !0 && (u = `(?:^(?!${u}).*$)`), u;
  }, t.basename = (s, { windows: o } = {}) => {
    const l = s.split(o ? /[\\/]/ : "/"), a = l[l.length - 1];
    return a === "" ? l[l.length - 2] : a;
  };
})(Ye);
const Tn = Ye, {
  CHAR_ASTERISK: Yt,
  /* * */
  CHAR_AT: lc,
  /* @ */
  CHAR_BACKWARD_SLASH: Ve,
  /* \ */
  CHAR_COMMA: cc,
  /* , */
  CHAR_DOT: Zt,
  /* . */
  CHAR_EXCLAMATION_MARK: Qt,
  /* ! */
  CHAR_FORWARD_SLASH: vs,
  /* / */
  CHAR_LEFT_CURLY_BRACE: Jt,
  /* { */
  CHAR_LEFT_PARENTHESES: er,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: uc,
  /* [ */
  CHAR_PLUS: fc,
  /* + */
  CHAR_QUESTION_MARK: In,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE: hc,
  /* } */
  CHAR_RIGHT_PARENTHESES: xn,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: pc
  /* ] */
} = Ot, Cn = (t) => t === vs || t === Ve, Nn = (t) => {
  t.isPrefix !== !0 && (t.depth = t.isGlobstar ? 1 / 0 : 1);
}, dc = (t, e) => {
  const r = e || {}, n = t.length - 1, i = r.parts === !0 || r.scanToEnd === !0, s = [], o = [], l = [];
  let a = t, c = -1, u = 0, f = 0, d = !1, p = !1, y = !1, E = !1, w = !1, $ = !1, _ = !1, G = !1, C = !1, D = !1, j = 0, x, T, L = { value: "", depth: 0, isGlob: !1 };
  const m = () => c >= n, A = () => a.charCodeAt(c + 1), v = () => (x = T, a.charCodeAt(++c));
  for (; c < n; ) {
    T = v();
    let R;
    if (T === Ve) {
      _ = L.backslashes = !0, T = v(), T === Jt && ($ = !0);
      continue;
    }
    if ($ === !0 || T === Jt) {
      for (j++; m() !== !0 && (T = v()); ) {
        if (T === Ve) {
          _ = L.backslashes = !0, v();
          continue;
        }
        if (T === Jt) {
          j++;
          continue;
        }
        if ($ !== !0 && T === Zt && (T = v()) === Zt) {
          if (d = L.isBrace = !0, y = L.isGlob = !0, D = !0, i === !0)
            continue;
          break;
        }
        if ($ !== !0 && T === cc) {
          if (d = L.isBrace = !0, y = L.isGlob = !0, D = !0, i === !0)
            continue;
          break;
        }
        if (T === hc && (j--, j === 0)) {
          $ = !1, d = L.isBrace = !0, D = !0;
          break;
        }
      }
      if (i === !0)
        continue;
      break;
    }
    if (T === vs) {
      if (s.push(c), o.push(L), L = { value: "", depth: 0, isGlob: !1 }, D === !0)
        continue;
      if (x === Zt && c === u + 1) {
        u += 2;
        continue;
      }
      f = c + 1;
      continue;
    }
    if (r.noext !== !0 && (T === fc || T === lc || T === Yt || T === In || T === Qt) === !0 && A() === er) {
      if (y = L.isGlob = !0, E = L.isExtglob = !0, D = !0, T === Qt && c === u && (C = !0), i === !0) {
        for (; m() !== !0 && (T = v()); ) {
          if (T === Ve) {
            _ = L.backslashes = !0, T = v();
            continue;
          }
          if (T === xn) {
            y = L.isGlob = !0, D = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (T === Yt) {
      if (x === Yt && (w = L.isGlobstar = !0), y = L.isGlob = !0, D = !0, i === !0)
        continue;
      break;
    }
    if (T === In) {
      if (y = L.isGlob = !0, D = !0, i === !0)
        continue;
      break;
    }
    if (T === uc) {
      for (; m() !== !0 && (R = v()); ) {
        if (R === Ve) {
          _ = L.backslashes = !0, v();
          continue;
        }
        if (R === pc) {
          p = L.isBracket = !0, y = L.isGlob = !0, D = !0;
          break;
        }
      }
      if (i === !0)
        continue;
      break;
    }
    if (r.nonegate !== !0 && T === Qt && c === u) {
      G = L.negated = !0, u++;
      continue;
    }
    if (r.noparen !== !0 && T === er) {
      if (y = L.isGlob = !0, i === !0) {
        for (; m() !== !0 && (T = v()); ) {
          if (T === er) {
            _ = L.backslashes = !0, T = v();
            continue;
          }
          if (T === xn) {
            D = !0;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (y === !0) {
      if (D = !0, i === !0)
        continue;
      break;
    }
  }
  r.noext === !0 && (E = !1, y = !1);
  let S = a, h = "", g = "";
  u > 0 && (h = a.slice(0, u), a = a.slice(u), f -= u), S && y === !0 && f > 0 ? (S = a.slice(0, f), g = a.slice(f)) : y === !0 ? (S = "", g = a) : S = a, S && S !== "" && S !== "/" && S !== a && Cn(S.charCodeAt(S.length - 1)) && (S = S.slice(0, -1)), r.unescape === !0 && (g && (g = Tn.removeBackslashes(g)), S && _ === !0 && (S = Tn.removeBackslashes(S)));
  const b = {
    prefix: h,
    input: t,
    start: u,
    base: S,
    glob: g,
    isBrace: d,
    isBracket: p,
    isGlob: y,
    isExtglob: E,
    isGlobstar: w,
    negated: G,
    negatedExtglob: C
  };
  if (r.tokens === !0 && (b.maxDepth = 0, Cn(T) || o.push(L), b.tokens = o), r.parts === !0 || r.tokens === !0) {
    let R;
    for (let N = 0; N < s.length; N++) {
      const P = R ? R + 1 : u, F = s[N], V = t.slice(P, F);
      r.tokens && (N === 0 && u !== 0 ? (o[N].isPrefix = !0, o[N].value = h) : o[N].value = V, Nn(o[N]), b.maxDepth += o[N].depth), (N !== 0 || V !== "") && l.push(V), R = F;
    }
    if (R && R + 1 < t.length) {
      const N = t.slice(R + 1);
      l.push(N), r.tokens && (o[o.length - 1].value = N, Nn(o[o.length - 1]), b.maxDepth += o[o.length - 1].depth);
    }
    b.slashes = s, b.parts = l;
  }
  return b;
};
var gc = dc;
const gt = Ot, he = Ye, {
  MAX_LENGTH: mt,
  POSIX_REGEX_SOURCE: mc,
  REGEX_NON_SPECIAL_CHARS: Ec,
  REGEX_SPECIAL_CHARS_BACKREF: $c,
  REPLACEMENTS: ws
} = gt, yc = (t, e) => {
  if (typeof e.expandRange == "function")
    return e.expandRange(...t, e);
  t.sort();
  const r = `[${t.join("-")}]`;
  try {
    new RegExp(r);
  } catch {
    return t.map((i) => he.escapeRegex(i)).join("..");
  }
  return r;
}, De = (t, e) => `Missing ${t}: "${e}" - use "\\\\${e}" to match literal characters`, Sr = (t, e) => {
  if (typeof t != "string")
    throw new TypeError("Expected a string");
  t = ws[t] || t;
  const r = { ...e }, n = typeof r.maxLength == "number" ? Math.min(mt, r.maxLength) : mt;
  let i = t.length;
  if (i > n)
    throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
  const s = { type: "bos", value: "", output: r.prepend || "" }, o = [s], l = r.capture ? "" : "?:", a = gt.globChars(r.windows), c = gt.extglobChars(a), {
    DOT_LITERAL: u,
    PLUS_LITERAL: f,
    SLASH_LITERAL: d,
    ONE_CHAR: p,
    DOTS_SLASH: y,
    NO_DOT: E,
    NO_DOT_SLASH: w,
    NO_DOTS_SLASH: $,
    QMARK: _,
    QMARK_NO_DOT: G,
    STAR: C,
    START_ANCHOR: D
  } = a, j = (I) => `(${l}(?:(?!${D}${I.dot ? y : u}).)*?)`, x = r.dot ? "" : E, T = r.dot ? _ : G;
  let L = r.bash === !0 ? j(r) : C;
  r.capture && (L = `(${L})`), typeof r.noext == "boolean" && (r.noextglob = r.noext);
  const m = {
    input: t,
    index: -1,
    start: 0,
    dot: r.dot === !0,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: !1,
    negated: !1,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: !1,
    tokens: o
  };
  t = he.removePrefix(t, m), i = t.length;
  const A = [], v = [], S = [];
  let h = s, g;
  const b = () => m.index === i - 1, R = m.peek = (I = 1) => t[m.index + I], N = m.advance = () => t[++m.index] || "", P = () => t.slice(m.index + 1), F = (I = "", W = 0) => {
    m.consumed += I, m.index += W;
  }, V = (I) => {
    m.output += I.output != null ? I.output : I.value, F(I.value);
  }, M = () => {
    let I = 1;
    for (; R() === "!" && (R(2) !== "(" || R(3) === "?"); )
      N(), m.start++, I++;
    return I % 2 === 0 ? !1 : (m.negated = !0, m.start++, !0);
  }, ne = (I) => {
    m[I]++, S.push(I);
  }, ie = (I) => {
    m[I]--, S.pop();
  }, H = (I) => {
    if (h.type === "globstar") {
      const W = m.braces > 0 && (I.type === "comma" || I.type === "brace"), O = I.extglob === !0 || A.length && (I.type === "pipe" || I.type === "paren");
      I.type !== "slash" && I.type !== "paren" && !W && !O && (m.output = m.output.slice(0, -h.output.length), h.type = "star", h.value = "*", h.output = L, m.output += h.output);
    }
    if (A.length && I.type !== "paren" && (A[A.length - 1].inner += I.value), (I.value || I.output) && V(I), h && h.type === "text" && I.type === "text") {
      h.output = (h.output || h.value) + I.value, h.value += I.value;
      return;
    }
    I.prev = h, o.push(I), h = I;
  }, be = (I, W) => {
    const O = { ...c[W], conditions: 1, inner: "" };
    O.prev = h, O.parens = m.parens, O.output = m.output;
    const U = (r.capture ? "(" : "") + O.open;
    ne("parens"), H({ type: I, value: W, output: m.output ? "" : p }), H({ type: "paren", extglob: !0, value: N(), output: U }), A.push(O);
  }, Fs = (I) => {
    let W = I.close + (r.capture ? ")" : ""), O;
    if (I.type === "negate") {
      let U = L;
      if (I.inner && I.inner.length > 1 && I.inner.includes("/") && (U = j(r)), (U !== L || b() || /^\)+$/.test(P())) && (W = I.close = `)$))${U}`), I.inner.includes("*") && (O = P()) && /^\.[^\\/.]+$/.test(O)) {
        const X = Sr(O, { ...e, fastpaths: !1 }).output;
        W = I.close = `)${X})${U})`;
      }
      I.prev.type === "bos" && (m.negatedExtglob = !0);
    }
    H({ type: "paren", extglob: !0, value: g, output: W }), ie("parens");
  };
  if (r.fastpaths !== !1 && !/(^[*!]|[/()[\]{}"])/.test(t)) {
    let I = !1, W = t.replace($c, (O, U, X, ee, Z, Nt) => ee === "\\" ? (I = !0, O) : ee === "?" ? U ? U + ee + (Z ? _.repeat(Z.length) : "") : Nt === 0 ? T + (Z ? _.repeat(Z.length) : "") : _.repeat(X.length) : ee === "." ? u.repeat(X.length) : ee === "*" ? U ? U + ee + (Z ? L : "") : L : U ? O : `\\${O}`);
    return I === !0 && (r.unescape === !0 ? W = W.replace(/\\/g, "") : W = W.replace(/\\+/g, (O) => O.length % 2 === 0 ? "\\\\" : O ? "\\" : "")), W === t && r.contains === !0 ? (m.output = t, m) : (m.output = he.wrapOutput(W, m, e), m);
  }
  for (; !b(); ) {
    if (g = N(), g === "\0")
      continue;
    if (g === "\\") {
      const O = R();
      if (O === "/" && r.bash !== !0 || O === "." || O === ";")
        continue;
      if (!O) {
        g += "\\", H({ type: "text", value: g });
        continue;
      }
      const U = /^\\+/.exec(P());
      let X = 0;
      if (U && U[0].length > 2 && (X = U[0].length, m.index += X, X % 2 !== 0 && (g += "\\")), r.unescape === !0 ? g = N() : g += N(), m.brackets === 0) {
        H({ type: "text", value: g });
        continue;
      }
    }
    if (m.brackets > 0 && (g !== "]" || h.value === "[" || h.value === "[^")) {
      if (r.posix !== !1 && g === ":") {
        const O = h.value.slice(1);
        if (O.includes("[") && (h.posix = !0, O.includes(":"))) {
          const U = h.value.lastIndexOf("["), X = h.value.slice(0, U), ee = h.value.slice(U + 2), Z = mc[ee];
          if (Z) {
            h.value = X + Z, m.backtrack = !0, N(), !s.output && o.indexOf(h) === 1 && (s.output = p);
            continue;
          }
        }
      }
      (g === "[" && R() !== ":" || g === "-" && R() === "]") && (g = `\\${g}`), g === "]" && (h.value === "[" || h.value === "[^") && (g = `\\${g}`), r.posix === !0 && g === "!" && h.value === "[" && (g = "^"), h.value += g, V({ value: g });
      continue;
    }
    if (m.quotes === 1 && g !== '"') {
      g = he.escapeRegex(g), h.value += g, V({ value: g });
      continue;
    }
    if (g === '"') {
      m.quotes = m.quotes === 1 ? 0 : 1, r.keepQuotes === !0 && H({ type: "text", value: g });
      continue;
    }
    if (g === "(") {
      ne("parens"), H({ type: "paren", value: g });
      continue;
    }
    if (g === ")") {
      if (m.parens === 0 && r.strictBrackets === !0)
        throw new SyntaxError(De("opening", "("));
      const O = A[A.length - 1];
      if (O && m.parens === O.parens + 1) {
        Fs(A.pop());
        continue;
      }
      H({ type: "paren", value: g, output: m.parens ? ")" : "\\)" }), ie("parens");
      continue;
    }
    if (g === "[") {
      if (r.nobracket === !0 || !P().includes("]")) {
        if (r.nobracket !== !0 && r.strictBrackets === !0)
          throw new SyntaxError(De("closing", "]"));
        g = `\\${g}`;
      } else
        ne("brackets");
      H({ type: "bracket", value: g });
      continue;
    }
    if (g === "]") {
      if (r.nobracket === !0 || h && h.type === "bracket" && h.value.length === 1) {
        H({ type: "text", value: g, output: `\\${g}` });
        continue;
      }
      if (m.brackets === 0) {
        if (r.strictBrackets === !0)
          throw new SyntaxError(De("opening", "["));
        H({ type: "text", value: g, output: `\\${g}` });
        continue;
      }
      ie("brackets");
      const O = h.value.slice(1);
      if (h.posix !== !0 && O[0] === "^" && !O.includes("/") && (g = `/${g}`), h.value += g, V({ value: g }), r.literalBrackets === !1 || he.hasRegexChars(O))
        continue;
      const U = he.escapeRegex(h.value);
      if (m.output = m.output.slice(0, -h.value.length), r.literalBrackets === !0) {
        m.output += U, h.value = U;
        continue;
      }
      h.value = `(${l}${U}|${h.value})`, m.output += h.value;
      continue;
    }
    if (g === "{" && r.nobrace !== !0) {
      ne("braces");
      const O = {
        type: "brace",
        value: g,
        output: "(",
        outputIndex: m.output.length,
        tokensIndex: m.tokens.length
      };
      v.push(O), H(O);
      continue;
    }
    if (g === "}") {
      const O = v[v.length - 1];
      if (r.nobrace === !0 || !O) {
        H({ type: "text", value: g, output: g });
        continue;
      }
      let U = ")";
      if (O.dots === !0) {
        const X = o.slice(), ee = [];
        for (let Z = X.length - 1; Z >= 0 && (o.pop(), X[Z].type !== "brace"); Z--)
          X[Z].type !== "dots" && ee.unshift(X[Z].value);
        U = yc(ee, r), m.backtrack = !0;
      }
      if (O.comma !== !0 && O.dots !== !0) {
        const X = m.output.slice(0, O.outputIndex), ee = m.tokens.slice(O.tokensIndex);
        O.value = O.output = "\\{", g = U = "\\}", m.output = X;
        for (const Z of ee)
          m.output += Z.output || Z.value;
      }
      H({ type: "brace", value: g, output: U }), ie("braces"), v.pop();
      continue;
    }
    if (g === "|") {
      A.length > 0 && A[A.length - 1].conditions++, H({ type: "text", value: g });
      continue;
    }
    if (g === ",") {
      let O = g;
      const U = v[v.length - 1];
      U && S[S.length - 1] === "braces" && (U.comma = !0, O = "|"), H({ type: "comma", value: g, output: O });
      continue;
    }
    if (g === "/") {
      if (h.type === "dot" && m.index === m.start + 1) {
        m.start = m.index + 1, m.consumed = "", m.output = "", o.pop(), h = s;
        continue;
      }
      H({ type: "slash", value: g, output: d });
      continue;
    }
    if (g === ".") {
      if (m.braces > 0 && h.type === "dot") {
        h.value === "." && (h.output = u);
        const O = v[v.length - 1];
        h.type = "dots", h.output += g, h.value += g, O.dots = !0;
        continue;
      }
      if (m.braces + m.parens === 0 && h.type !== "bos" && h.type !== "slash") {
        H({ type: "text", value: g, output: u });
        continue;
      }
      H({ type: "dot", value: g, output: u });
      continue;
    }
    if (g === "?") {
      if (!(h && h.value === "(") && r.noextglob !== !0 && R() === "(" && R(2) !== "?") {
        be("qmark", g);
        continue;
      }
      if (h && h.type === "paren") {
        const U = R();
        let X = g;
        (h.value === "(" && !/[!=<:]/.test(U) || U === "<" && !/<([!=]|\w+>)/.test(P())) && (X = `\\${g}`), H({ type: "text", value: g, output: X });
        continue;
      }
      if (r.dot !== !0 && (h.type === "slash" || h.type === "bos")) {
        H({ type: "qmark", value: g, output: G });
        continue;
      }
      H({ type: "qmark", value: g, output: _ });
      continue;
    }
    if (g === "!") {
      if (r.noextglob !== !0 && R() === "(" && (R(2) !== "?" || !/[!=<:]/.test(R(3)))) {
        be("negate", g);
        continue;
      }
      if (r.nonegate !== !0 && m.index === 0) {
        M();
        continue;
      }
    }
    if (g === "+") {
      if (r.noextglob !== !0 && R() === "(" && R(2) !== "?") {
        be("plus", g);
        continue;
      }
      if (h && h.value === "(" || r.regex === !1) {
        H({ type: "plus", value: g, output: f });
        continue;
      }
      if (h && (h.type === "bracket" || h.type === "paren" || h.type === "brace") || m.parens > 0) {
        H({ type: "plus", value: g });
        continue;
      }
      H({ type: "plus", value: f });
      continue;
    }
    if (g === "@") {
      if (r.noextglob !== !0 && R() === "(" && R(2) !== "?") {
        H({ type: "at", extglob: !0, value: g, output: "" });
        continue;
      }
      H({ type: "text", value: g });
      continue;
    }
    if (g !== "*") {
      (g === "$" || g === "^") && (g = `\\${g}`);
      const O = Ec.exec(P());
      O && (g += O[0], m.index += O[0].length), H({ type: "text", value: g });
      continue;
    }
    if (h && (h.type === "globstar" || h.star === !0)) {
      h.type = "star", h.star = !0, h.value += g, h.output = L, m.backtrack = !0, m.globstar = !0, F(g);
      continue;
    }
    let I = P();
    if (r.noextglob !== !0 && /^\([^?]/.test(I)) {
      be("star", g);
      continue;
    }
    if (h.type === "star") {
      if (r.noglobstar === !0) {
        F(g);
        continue;
      }
      const O = h.prev, U = O.prev, X = O.type === "slash" || O.type === "bos", ee = U && (U.type === "star" || U.type === "globstar");
      if (r.bash === !0 && (!X || I[0] && I[0] !== "/")) {
        H({ type: "star", value: g, output: "" });
        continue;
      }
      const Z = m.braces > 0 && (O.type === "comma" || O.type === "brace"), Nt = A.length && (O.type === "pipe" || O.type === "paren");
      if (!X && O.type !== "paren" && !Z && !Nt) {
        H({ type: "star", value: g, output: "" });
        continue;
      }
      for (; I.slice(0, 3) === "/**"; ) {
        const Je = t[m.index + 4];
        if (Je && Je !== "/")
          break;
        I = I.slice(3), F("/**", 3);
      }
      if (O.type === "bos" && b()) {
        h.type = "globstar", h.value += g, h.output = j(r), m.output = h.output, m.globstar = !0, F(g);
        continue;
      }
      if (O.type === "slash" && O.prev.type !== "bos" && !ee && b()) {
        m.output = m.output.slice(0, -(O.output + h.output).length), O.output = `(?:${O.output}`, h.type = "globstar", h.output = j(r) + (r.strictSlashes ? ")" : "|$)"), h.value += g, m.globstar = !0, m.output += O.output + h.output, F(g);
        continue;
      }
      if (O.type === "slash" && O.prev.type !== "bos" && I[0] === "/") {
        const Je = I[1] !== void 0 ? "|$" : "";
        m.output = m.output.slice(0, -(O.output + h.output).length), O.output = `(?:${O.output}`, h.type = "globstar", h.output = `${j(r)}${d}|${d}${Je})`, h.value += g, m.output += O.output + h.output, m.globstar = !0, F(g + N()), H({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (O.type === "bos" && I[0] === "/") {
        h.type = "globstar", h.value += g, h.output = `(?:^|${d}|${j(r)}${d})`, m.output = h.output, m.globstar = !0, F(g + N()), H({ type: "slash", value: "/", output: "" });
        continue;
      }
      m.output = m.output.slice(0, -h.output.length), h.type = "globstar", h.output = j(r), h.value += g, m.output += h.output, m.globstar = !0, F(g);
      continue;
    }
    const W = { type: "star", value: g, output: L };
    if (r.bash === !0) {
      W.output = ".*?", (h.type === "bos" || h.type === "slash") && (W.output = x + W.output), H(W);
      continue;
    }
    if (h && (h.type === "bracket" || h.type === "paren") && r.regex === !0) {
      W.output = g, H(W);
      continue;
    }
    (m.index === m.start || h.type === "slash" || h.type === "dot") && (h.type === "dot" ? (m.output += w, h.output += w) : r.dot === !0 ? (m.output += $, h.output += $) : (m.output += x, h.output += x), R() !== "*" && (m.output += p, h.output += p)), H(W);
  }
  for (; m.brackets > 0; ) {
    if (r.strictBrackets === !0)
      throw new SyntaxError(De("closing", "]"));
    m.output = he.escapeLast(m.output, "["), ie("brackets");
  }
  for (; m.parens > 0; ) {
    if (r.strictBrackets === !0)
      throw new SyntaxError(De("closing", ")"));
    m.output = he.escapeLast(m.output, "("), ie("parens");
  }
  for (; m.braces > 0; ) {
    if (r.strictBrackets === !0)
      throw new SyntaxError(De("closing", "}"));
    m.output = he.escapeLast(m.output, "{"), ie("braces");
  }
  if (r.strictSlashes !== !0 && (h.type === "star" || h.type === "bracket") && H({ type: "maybe_slash", value: "", output: `${d}?` }), m.backtrack === !0) {
    m.output = "";
    for (const I of m.tokens)
      m.output += I.output != null ? I.output : I.value, I.suffix && (m.output += I.suffix);
  }
  return m;
};
Sr.fastpaths = (t, e) => {
  const r = { ...e }, n = typeof r.maxLength == "number" ? Math.min(mt, r.maxLength) : mt, i = t.length;
  if (i > n)
    throw new SyntaxError(`Input length: ${i}, exceeds maximum allowed length: ${n}`);
  t = ws[t] || t;
  const {
    DOT_LITERAL: s,
    SLASH_LITERAL: o,
    ONE_CHAR: l,
    DOTS_SLASH: a,
    NO_DOT: c,
    NO_DOTS: u,
    NO_DOTS_SLASH: f,
    STAR: d,
    START_ANCHOR: p
  } = gt.globChars(r.windows), y = r.dot ? u : c, E = r.dot ? f : c, w = r.capture ? "" : "?:", $ = { negated: !1, prefix: "" };
  let _ = r.bash === !0 ? ".*?" : d;
  r.capture && (_ = `(${_})`);
  const G = (x) => x.noglobstar === !0 ? _ : `(${w}(?:(?!${p}${x.dot ? a : s}).)*?)`, C = (x) => {
    switch (x) {
      case "*":
        return `${y}${l}${_}`;
      case ".*":
        return `${s}${l}${_}`;
      case "*.*":
        return `${y}${_}${s}${l}${_}`;
      case "*/*":
        return `${y}${_}${o}${l}${E}${_}`;
      case "**":
        return y + G(r);
      case "**/*":
        return `(?:${y}${G(r)}${o})?${E}${l}${_}`;
      case "**/*.*":
        return `(?:${y}${G(r)}${o})?${E}${_}${s}${l}${_}`;
      case "**/.*":
        return `(?:${y}${G(r)}${o})?${s}${l}${_}`;
      default: {
        const T = /^(.*?)\.(\w+)$/.exec(x);
        if (!T)
          return;
        const L = C(T[1]);
        return L ? L + s + T[2] : void 0;
      }
    }
  }, D = he.removePrefix(t, $);
  let j = C(D);
  return j && r.strictSlashes !== !0 && (j += `${o}?`), j;
};
var vc = Sr;
const wc = gc, lr = vc, As = Ye, Ac = Ot, bc = (t) => t && typeof t == "object" && !Array.isArray(t), K = (t, e, r = !1) => {
  if (Array.isArray(t)) {
    const u = t.map((d) => K(d, e, r));
    return (d) => {
      for (const p of u) {
        const y = p(d);
        if (y)
          return y;
      }
      return !1;
    };
  }
  const n = bc(t) && t.tokens && t.input;
  if (t === "" || typeof t != "string" && !n)
    throw new TypeError("Expected pattern to be a non-empty string");
  const i = e || {}, s = i.windows, o = n ? K.compileRe(t, e) : K.makeRe(t, e, !1, !0), l = o.state;
  delete o.state;
  let a = () => !1;
  if (i.ignore) {
    const u = { ...e, ignore: null, onMatch: null, onResult: null };
    a = K(i.ignore, u, r);
  }
  const c = (u, f = !1) => {
    const { isMatch: d, match: p, output: y } = K.test(u, o, e, { glob: t, posix: s }), E = { glob: t, state: l, regex: o, posix: s, input: u, output: y, match: p, isMatch: d };
    return typeof i.onResult == "function" && i.onResult(E), d === !1 ? (E.isMatch = !1, f ? E : !1) : a(u) ? (typeof i.onIgnore == "function" && i.onIgnore(E), E.isMatch = !1, f ? E : !1) : (typeof i.onMatch == "function" && i.onMatch(E), f ? E : !0);
  };
  return r && (c.state = l), c;
};
K.test = (t, e, r, { glob: n, posix: i } = {}) => {
  if (typeof t != "string")
    throw new TypeError("Expected input to be a string");
  if (t === "")
    return { isMatch: !1, output: "" };
  const s = r || {}, o = s.format || (i ? As.toPosixSlashes : null);
  let l = t === n, a = l && o ? o(t) : t;
  return l === !1 && (a = o ? o(t) : t, l = a === n), (l === !1 || s.capture === !0) && (s.matchBase === !0 || s.basename === !0 ? l = K.matchBase(t, e, r, i) : l = e.exec(a)), { isMatch: !!l, match: l, output: a };
};
K.matchBase = (t, e, r) => (e instanceof RegExp ? e : K.makeRe(e, r)).test(As.basename(t));
K.isMatch = (t, e, r) => K(e, r)(t);
K.parse = (t, e) => Array.isArray(t) ? t.map((r) => K.parse(r, e)) : lr(t, { ...e, fastpaths: !1 });
K.scan = (t, e) => wc(t, e);
K.compileRe = (t, e, r = !1, n = !1) => {
  if (r === !0)
    return t.output;
  const i = e || {}, s = i.contains ? "" : "^", o = i.contains ? "" : "$";
  let l = `${s}(?:${t.output})${o}`;
  t && t.negated === !0 && (l = `^(?!${l}).*$`);
  const a = K.toRegex(l, e);
  return n === !0 && (a.state = t), a;
};
K.makeRe = (t, e = {}, r = !1, n = !1) => {
  if (!t || typeof t != "string")
    throw new TypeError("Expected a non-empty string");
  let i = { negated: !1, fastpaths: !0 };
  return e.fastpaths !== !1 && (t[0] === "." || t[0] === "*") && (i.output = lr.fastpaths(t, e)), i.output || (i = lr(t, e)), K.compileRe(i, e, r, n);
};
K.toRegex = (t, e) => {
  try {
    const r = e || {};
    return new RegExp(t, r.flags || (r.nocase ? "i" : ""));
  } catch (r) {
    if (e && e.debug === !0)
      throw r;
    return /$^/;
  }
};
K.constants = Ac;
var Rc = K;
const bs = Rc, _c = Ye;
function Rs(t, e, r = !1) {
  return e && (e.windows === null || e.windows === void 0) && (e = { ...e, windows: _c.isWindows() }), bs(t, e, r);
}
Object.assign(Rs, bs);
var Sc = Rs;
const Ln = /* @__PURE__ */ Ge(Sc), Oc = "16.1.1", Tc = /^.*?:\/\/(.*?@)?(github\.com[:/])/i, Ic = /^([^/]+)\/([^/#]+)?.*?\/([0-9a-f]+|v?[0-9]+\.[0-9]+\.[0-9]+)$/i, cr = /^[0-9a-f]{7,}$/i, Dn = /[0-9]+(\.[0-9]+)?(\.[0-9]+)?/g, Et = (t) => t.replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&"), xc = Ke(Ll.fromUrl), tr = Ke(pi), Tt = Ke((t) => t.endsWith("/") ? t.substring(0, t.length - 1) : t), _s = Oc, $e = "\0", k = Ys(Us.slice(2), {
  boolean: [
    "E",
    "error-on-outdated",
    "U",
    "error-on-unchanged",
    "h",
    "help",
    "j",
    "json",
    "n",
    "no-color",
    "u",
    "update",
    "v",
    "version",
    "V",
    "verbose"
  ],
  string: [
    "d",
    "allow-downgrade",
    "f",
    "file",
    "g",
    "greatest",
    "m",
    "minor",
    "P",
    "patch",
    "p",
    "prerelease",
    "R",
    "release",
    "r",
    "registry",
    "t",
    "types",
    "githubapi",
    // undocumented, only for tests
    "pypiapi"
    // undocumented, only for tests
  ],
  alias: {
    d: "allow-downgrade",
    E: "error-on-outdated",
    U: "error-on-unchanged",
    e: "exclude",
    f: "file",
    g: "greatest",
    h: "help",
    i: "include",
    j: "json",
    m: "minor",
    n: "no-color",
    P: "patch",
    p: "prerelease",
    r: "registry",
    R: "release",
    s: "semver",
    S: "sockets",
    t: "types",
    u: "update",
    v: "version",
    V: "verbose"
  }
});
(k["no-color"] || !Ul.stdout) && Ml();
const Pe = Ze(xe(k.greatest)), rr = Ze(xe(k.prerelease)), nr = Ze(xe(k.release)), Pn = Ze(xe(k.patch)), jn = Ze(xe(k.minor)), Hn = xe(k["allow-downgrade"]), Ss = k.githubapi ? Tt(k.githubapi) : "https://api.github.com", Cc = k.pypiapi ? Tt(k.pypiapi) : "https://pypi.org", ot = (t) => t.replace(/^v/, "");
function _e(t, e) {
  for (const r of e instanceof Set ? e : [])
    if (r.test(t))
      return !0;
  return !1;
}
const Nc = Ke((t, e) => {
  const r = e[`${t}:registry`] || e.registry;
  return r.endsWith("/") ? r : `${r}/`;
});
function Os(t, e) {
  const r = pr(e, t);
  try {
    return Vs(r), r;
  } catch {
  }
  const n = Jn(e);
  return n === e ? null : Os(t, n);
}
function Lc(t, e, r, n) {
  if (t.startsWith("@")) {
    const i = (/@[a-z0-9][\w-.]+/.exec(t) || [""])[0], s = Tt(Nc(i, n));
    if (s !== e)
      try {
        const o = tr(s, r);
        if (o?.token)
          return [o, s];
      } catch {
      }
    return [tr(e, r), e];
  } else
    return [tr(e, r), e];
}
const Ts = Ke((t, e, r) => ({
  ...Object.keys(t).length && { agentOpts: t },
  headers: {
    "user-agent": `updates/${_s}`,
    ...r && { Authorization: `${e} ${r}` }
  }
}));
async function Or(t, e) {
  k.verbose && console.error(`${Bl("fetch")} ${t}`);
  const r = await fetch(t, e);
  return k.verbose && console.error(`${r.ok ? br("done") : Ar("error")} ${t}`), r;
}
async function Dc(t, e, r, n, i, s) {
  const [o, l] = Lc(t, r, i, s), c = (e === "resolutions" ? ct(t) : t).replace(/\//g, "%2f"), u = `${l}/${c}`, f = await Or(u, Ts(n, o?.type, o?.token));
  if (f?.ok)
    return [await f.json(), e, l, t];
  throw f?.status && f?.statusText ? new Error(`Received ${f.status} ${f.statusText} for ${t} from ${l}`) : new Error(`Unable to fetch ${t} from ${l}`);
}
async function Pc(t, e, r) {
  const n = `${Cc}/pypi/${t}/json`, i = await Or(n, Ts(r));
  if (i?.ok)
    return [await i.json(), e, null, t];
  throw i?.status && i?.statusText ? new Error(`Received ${i.status} ${i.statusText} for ${t} from PyPi`) : new Error(`Unable to fetch ${t} from PyPi`);
}
function Fn({ repository: t, homepage: e, info: r }, n, i) {
  r && (t = r.project_urls.repository || r.project_urls.Repository || r.project_urls.repo || r.project_urls.Repo || r.project_urls.source || r.project_urls.Source || r.project_urls["source code"] || r.project_urls["Source Code"] || r.project_urls.homepage || r.project_urls.Homepage || `https://pypi.org/project/${i}/`);
  let s;
  if (n === "https://npm.pkg.github.com")
    return `https://github.com/${i.replace(/^@/, "")}`;
  if (t) {
    const o = typeof t == "string" ? t : t.url, l = xc(o), a = l?.browse?.();
    a && (s = a), s && typeof t != "string" && t.directory && l?.treepath && (s = `${s}/${l.treepath}/HEAD/${t.directory}`), !s && typeof t != "string" && t?.url && /^https?:/.test(t.url) && (s = t.url), !s && o && (s = o);
  }
  return s || e || "";
}
function Gn(t) {
  console.info(k.json ? JSON.stringify({ message: t }) : t), Xe();
}
function Xe(t) {
  if (t) {
    const e = t.stack ?? t.message;
    console.info(k.json ? JSON.stringify({ error: e }) : Ar(e));
  }
  process.exit(t ? 1 : 0);
}
function jc(t = {}) {
  for (const r of Object.keys(t))
    for (const n of Object.values(t[r]))
      typeof n.oldPrint == "string" && (n.old = n.oldPrint, delete n.oldPrint), typeof n.newPrint == "string" && (n.new = n.newPrint, delete n.newPrint), typeof n.oldOriginal == "string" && (n.old = n.oldOriginal, delete n.oldOriginal);
  let e = 0;
  for (const r of Object.keys(t))
    e += Object.keys(t[r]).length;
  if (k.json) {
    const r = { results: {} };
    for (const n of Object.keys(t))
      for (const [i, s] of Object.entries(t[n])) {
        const [o, l] = i.split($e);
        r.results[n] || (r.results[n] = {}), r.results[n][o] || (r.results[n][o] = {}), r.results[n][o][l] = s;
      }
    console.info(JSON.stringify(r));
  } else
    e && console.info(Fc(t));
  return k["error-on-outdated"] ? e ? 2 : 0 : k["error-on-unchanged"] ? e ? 0 : 2 : 0;
}
async function Hc(t, e) {
  const { platform: r } = await import("node:os"), n = r() === "win32";
  n && ks(t, 0), zs(t, e, n ? { flag: "r+" } : void 0);
}
function Un(t, e, r) {
  if (t === e)
    return t;
  const n = t.split(/\./), i = e.split(/\./), s = /^[0-9a-zA-Z-.]+$/;
  let o = "";
  for (let l = 0; l < n.length; l++)
    if (n[l] !== i[l]) {
      s.test(n[l]) ? o += r(n.slice(l).join(".")) : o += n[l].split("").map((a) => s.test(a) ? r(a) : a).join("") + r(`.${n.slice(l + 1).join(".")}`.replace(/\.$/, ""));
      break;
    } else
      o += `${n[l]}.`;
  return o.replace(/\.$/, "");
}
function Fc(t) {
  const e = [["NAME", "OLD", "NEW", "AGE", "INFO"]], r = /* @__PURE__ */ new Set();
  for (const n of Object.keys(t))
    for (const [i, s] of Object.entries(t[n])) {
      const o = i.split($e)[1], l = `${n}|${o}`;
      r.has(l) || (r.add(l), e.push([
        o,
        Un(s.old, s.new, Ar),
        Un(s.new, s.old, br),
        s.age || "",
        s.info || ""
      ]));
    }
  return El(e, {
    hsep: " ",
    stringLength: (n) => n.replace(qs(), "").length
  });
}
function Gc(t, e) {
  let r = t;
  for (const n of Object.keys(e)) {
    const i = n.split($e)[1], s = e[n].oldOriginal || e[n].old, o = new RegExp(`"${Et(i)}": *"${Et(s)}"`, "g");
    r = r.replace(o, `"${i}": "${e[n].new}"`);
  }
  return r;
}
function Uc(t, e) {
  let r = t;
  for (const n of Object.keys(e)) {
    const i = n.split($e)[1], s = e[n].oldOriginal || e[n].old, o = new RegExp(`${Et(i)} *= *"${Et(s)}"`, "g");
    r = r.replace(o, `${i} = "${e[n].new}"`);
  }
  return r;
}
function Mc(t, e, r) {
  let n = t.replace(/[0-9]+\.[0-9]+\.[0-9]+(-.+)?/g, e);
  if (r && r !== t && /^[\^~]/.test(n)) {
    const i = r.substring(1).split("."), s = n.substring(1).split(".");
    i.length !== s.length && (n = `${n[0]}${s.slice(0, i.length).join(".")}`);
  }
  return n;
}
function sr(t) {
  const e = J.parse(t);
  return e ? !!e.prerelease.length : !1;
}
function Is(t) {
  return /[0-9]+\.[0-9]+\.[0-9]+-.+/.test(t);
}
function qe(t) {
  try {
    return J.coerce(t)?.version ?? "";
  } catch {
    return "";
  }
}
function Bc(t, e, { range: r, semvers: n, usePre: i, useRel: s, useGreatest: o }) {
  let l = qe(r), a = 0;
  i = Is(r) || i, i && (n.add("prerelease"), n.has("patch") && n.add("prepatch"), n.has("minor") && n.add("preminor"), n.has("major") && n.add("premajor"));
  for (const c of e) {
    const u = J.parse(c);
    if (!u || !l || u.prerelease.length && (!i || s))
      continue;
    const f = J.diff(l, u.version);
    if (!(!f || !n.has(f)))
      if (o || !("time" in t))
        J.gte(qe(u?.version), l) && (l = u.version);
      else {
        const d = new Date(t.time[c]).getTime();
        d >= 0 && d > a && (l = u.version, a = d);
      }
  }
  return l || null;
}
function kc(t, { mode: e, range: r, useGreatest: n, useRel: i, usePre: s, semvers: o }) {
  if (r === "*" || r.includes("||"))
    return null;
  const l = Object.keys(e === "pypi" ? t.releases : t.versions).filter((c) => J.valid(c)), a = Bc(t, l, { range: r, semvers: o, usePre: s, useRel: i, useGreatest: n });
  if (!a)
    return null;
  if (n)
    return a;
  {
    let c, u;
    e === "pypi" ? (u = t.info.version, c = qe(t.info.version)) : c = t["dist-tags"].latest;
    const f = qe(r), d = Is(r), p = sr(a), y = sr(c), E = J.gt(a, f);
    if (!i && s || d && p || i && !E && d && !p || d && !p && E)
      return a;
    if (d && !p && !E)
      return null;
    const w = J.diff(f, c);
    return w && w !== "prerelease" && !o.has(w.replace(/^pre/, "")) || i && sr(c) ? a : J.lt(c, f) && !y ? Hn === !0 || _e(t.name, Hn) ? c : null : u ?? c;
  }
}
function xs(t) {
  const e = {}, r = et.UPDATES_GITHUB_API_TOKEN || et.GITHUB_API_TOKEN || et.GH_TOKEN || et.HOMEBREW_GITHUB_API_TOKEN;
  return r && (e.headers = { Authorization: `Bearer ${r}` }), Or(t, e);
}
async function zc(t, e) {
  const r = `${Ss}/repos/${t}/${e}/commits`, n = await xs(r);
  if (!n || !n.ok)
    return { hash: "", commit: {} };
  const i = await n.json(), { sha: s, commit: o } = i[0];
  return { hash: s, commit: o };
}
async function Vc(t, e) {
  const r = await xs(`${Ss}/repos/${t}/${e}/git/refs/tags`);
  return !r || !r.ok ? [] : (await r.json()).map((s) => s.ref.replace(/^refs\/tags\//, ""));
}
function Wc(t, e, r) {
  const n = ot(e);
  if (J.valid(n))
    if (r) {
      let i = e, s = ot(e);
      for (const o of t) {
        const l = ot(o);
        J.valid(l) && (!i || J.gt(l, s)) && (i = o, s = l);
      }
      if (J.neq(n, s))
        return i;
    } else {
      const i = t.at(-1);
      if (!i)
        return;
      const s = ot(i);
      if (!J.valid(s))
        return;
      if (J.neq(n, s))
        return i;
    }
}
async function Xc(t, e, r) {
  const n = e.old.replace(Tc, ""), [i, s, o, l] = Ic.exec(n) || [];
  if (!(!s || !o || !l))
    if (cr.test(l)) {
      const { hash: a, commit: c } = await zc(s, o);
      if (!a)
        return;
      const u = c?.committer?.date ?? c?.author?.date, f = a.substring(0, l.length);
      if (l !== f) {
        const d = e.old.replace(l, f);
        return { key: t, newRange: d, user: s, repo: o, oldRef: l, newRef: f, newDate: u };
      }
    } else {
      const a = await Vc(s, o), c = Wc(a, l, r);
      if (c)
        return { key: t, newRange: c, user: s, repo: o, oldRef: l, newRef: c };
    }
}
function qc(t) {
  const e = t.match(Dn);
  return e?.length !== 1 ? t : t.replace(Dn, qe(e[0]));
}
function xe(t) {
  return t === void 0 ? !1 : t === "" ? !0 : typeof t == "string" ? t.includes(",") ? new Set(t.split(",")) : /* @__PURE__ */ new Set([t]) : Array.isArray(t) ? new Set(t) : !1;
}
function Mn(t) {
  return Array.from(t.matchAll(/(----BEGIN CERT[^]+?IFICATE----)/g), (e) => e[0]);
}
async function Bn(t = []) {
  return [...(await import("node:tls")).rootCertificates, ...t];
}
function ur(t, e) {
  return e && typeof t == "string" ? /\/.+\//.test(t) ? new RegExp(t.slice(1, -1)) : Ln.makeRe(t) : t instanceof RegExp ? t : Ln.makeRe(t);
}
function Ze(t) {
  if (t instanceof Set) {
    const e = /* @__PURE__ */ new Set();
    for (const r of t)
      e.add(ur(r, !0));
    return e;
  }
  return t;
}
function kn(t, e) {
  const r = /* @__PURE__ */ new Set();
  for (const n of t || [])
    r.add(ur(n, !0));
  for (const n of e || [])
    r.add(ur(n, !1));
  return r;
}
function zn(t, e, r, n) {
  if (e === "pypi" && t === "python")
    return !1;
  if (!r.size && !n.size)
    return !0;
  for (const i of n)
    if (i.test(t))
      return !1;
  for (const i of r)
    if (i.test(t))
      return !0;
  return !r.size;
}
function Kc(t) {
  const e = /* @__PURE__ */ new Set();
  if (t)
    for (const r of t) {
      let n;
      try {
        n = Lr(r);
      } catch (i) {
        throw new Error(`Unable to open ${r}: ${i.message}`);
      }
      if (n?.isFile())
        e.add(lt(r));
      else if (n?.isDirectory())
        for (const i of ["package.json", "pyproject.toml"]) {
          const s = pr(r, i);
          let o;
          try {
            o = Lr(s);
          } catch {
          }
          o?.isFile() && e.add(lt(s));
        }
      else
        throw new Error(`${r} is neither a file nor directory`);
    }
  else
    for (const r of ["package.json", "pyproject.toml"]) {
      const n = Os(r, Bs());
      n && e.add(lt(n));
    }
  return e;
}
async function Yc() {
  for (const y of [process.stdout, process.stderr])
    y?._handle?.setBlocking?.(!0);
  const t = 96, e = typeof k.sockets == "number" ? k.sockets : t, { help: r, version: n, file: i, types: s, update: o } = k;
  r && (Ms.write(`usage: updates [options]

  Options:
    -u, --update                       Update versions and write package file
    -f, --file <path,...>              File or directory to use, defaults to current directory
    -i, --include <pkg,...>            Include only given packages
    -e, --exclude <pkg,...>            Exclude given packages
    -p, --prerelease [<pkg,...>]       Consider prerelease versions
    -R, --release [<pkg,...>]          Only use release versions, may downgrade
    -g, --greatest [<pkg,...>]         Prefer greatest over latest version
    -t, --types <type,...>             Check only given dependency types
    -P, --patch [<pkg,...>]            Consider only up to semver-patch
    -m, --minor [<pkg,...>]            Consider only up to semver-minor
    -d, --allow-downgrade [<pkg,...>]  Allow version downgrades when using latest version
    -E, --error-on-outdated            Exit with code 2 when updates are available and 0 when not
    -U, --error-on-unchanged           Exit with code 0 when updates are available and 2 when not
    -r, --registry <url>               Override npm registry URL
    -S, --sockets <num>                Maximum number of parallel HTTP sockets opened. Default: ${t}
    -j, --json                         Output a JSON object
    -n, --no-color                     Disable color output
    -v, --version                      Print the version
    -V, --verbose                      Print verbose output to stderr
    -h, --help                         Print this help

  Examples:
    $ updates
    $ updates -u
    $ updates -e '@vitejs/*'
    $ updates -e '/^react-(dom)?/'
    $ updates -f package.json
    $ updates -f pyproject.toml
`), Cr(0)), n && (console.info(_s), Cr(0));
  const l = {}, a = {}, c = {}, u = {};
  let f = 0;
  for (const y of Kc(xe(i))) {
    const E = Jn(lt(y)), $ = ct(y) === "pyproject.toml" ? "pypi" : "npm";
    u[$] = y, l[$] || (l[$] = {});
    let _ = {};
    try {
      ({ default: _ } = await Promise.any([
        "updates.config.js",
        "updates.config.ts",
        "updates.config.mjs",
        "updates.config.mts",
        ".config/updates.js",
        ".config/updates.ts",
        ".config/updates.mjs",
        ".config/updates.mts"
      ].map((h) => import(pr(E, ...h.split("/"))))));
    } catch {
    }
    let G = [], C = [];
    k.include && k.include !== !0 && (G = (Array.isArray(k.include) ? k.include : [k.include]).flatMap((h) => h.split(","))), k.exclude && k.exclude !== !0 && (C = (Array.isArray(k.exclude) ? k.exclude : [k.exclude]).flatMap((h) => h.split(",")));
    const D = kn(G, _?.include), j = kn(C, _?.exclude), x = {}, T = gi("npm", { registry: "https://registry.npmjs.org" }), L = { npmrc: T, recursive: !0 };
    if ($ === "npm" && (T["strict-ssl"] === !1 && (x.rejectUnauthorized = !1), T?.cafile && (x.ca = await Bn(Mn(Nr(T.cafile, "utf8")))), T?.ca)) {
      const h = Array.isArray(T.ca) ? T.ca : [T.ca];
      x.ca = await Bn(h.flatMap((g) => Mn(g)));
    }
    let m;
    s ? m = Array.isArray(s) ? s : s.split(",") : "types" in _ && Array.isArray(_.types) ? m = _.types : $ === "npm" ? m = [
      "dependencies",
      "devDependencies",
      "optionalDependencies",
      "peerDependencies",
      "resolutions"
    ] : m = [
      "tool.poetry.dependencies",
      "tool.poetry.dev-dependencies",
      "tool.poetry.test-dependencies",
      "tool.poetry.group.dev.dependencies",
      "tool.poetry.group.test.dependencies"
    ];
    let A;
    try {
      c[$] = Nr(y, "utf8");
    } catch (h) {
      throw new Error(`Unable to open ${y}: ${h.message}`);
    }
    try {
      $ === "npm" ? A = JSON.parse(c[$]) : A = (await Promise.resolve().then(() => Eu)).parse(c[$]);
    } catch (h) {
      throw new Error(`Error parsing ${y}: ${h.message}`);
    }
    for (const h of m) {
      let g;
      $ === "npm" ? g = A[h] || {} : g = Xl(A, h) || {};
      for (const [b, R] of Object.entries(g))
        J.validRange(R) && zn(b, $, D, j) ? l[$][`${h}${$e}${b}`] = {
          old: qc(R),
          oldOriginal: R
        } : $ === "npm" && zn(b, $, D, j) && (a[`${h}${$e}${b}`] = {
          old: R
        });
    }
    if (f += Object.keys(l[$]).length + Object.keys(a).length, !f)
      continue;
    let v;
    $ === "npm" && (v = Tt(k.registry || _.registry || T.registry));
    const S = await Sn(Object.keys(l[$]).map((h) => () => {
      const [g, b] = h.split($e);
      return $ === "npm" ? Dc(b, g, v, x, L, T) : Pc(b, g, x);
    }), { concurrency: e });
    for (const [h, g, b, R] of S) {
      if (h?.error)
        throw new Error(h.error);
      const N = typeof Pe == "boolean" ? Pe : _e(h.name, Pe), P = typeof rr == "boolean" ? rr : _e(h.name, rr), F = typeof nr == "boolean" ? nr : _e(h.name, nr);
      let V;
      Pn === !0 || _e(h.name, Pn) ? V = /* @__PURE__ */ new Set(["patch"]) : jn === !0 || _e(h.name, jn) ? V = /* @__PURE__ */ new Set(["patch", "minor"]) : V = /* @__PURE__ */ new Set(["patch", "minor", "major"]);
      const M = `${g}${$e}${R}`, ne = l[$][M].old, ie = l[$][M].oldOriginal, H = kc(h, {
        usePre: P,
        useRel: F,
        useGreatest: N,
        semvers: V,
        range: ne,
        mode: $
      }), be = Mc(ne, H, ie);
      !H || ie === be ? delete l[$][M] : (l[$][M].new = be, $ === "npm" ? l[$][M].info = Fn(h?.versions?.[H], b, h.name) : l[$][M].info = Fn(h, b, h.info.name), h.time?.[H] ? l[$][M].age = qt(h.time[H], { noAffix: !0 }) : h.releases?.[H]?.[0]?.upload_time_iso_8601 && (l[$][M].age = qt(h.releases[H][0].upload_time_iso_8601, { noAffix: !0 })));
    }
    if (Object.keys(a).length) {
      const h = await Sn(Object.entries(a).map(([g, b]) => () => {
        const R = g.split($e)[1], N = typeof Pe == "boolean" ? Pe : _e(R, Pe);
        return Xc(g, b, N);
      }), { concurrency: e });
      for (const g of (h || []).filter(Boolean)) {
        const { key: b, newRange: R, user: N, repo: P, oldRef: F, newRef: V, newDate: M } = g;
        l[$][b] = {
          // @ts-ignore
          old: a[b].old,
          new: R,
          oldPrint: cr.test(F) ? F.substring(0, 7) : F,
          newPrint: cr.test(V) ? V.substring(0, 7) : V,
          info: `https://github.com/${N}/${P}`,
          ...M ? { age: qt(M, { noAffix: !0 }) } : {}
        };
      }
    }
  }
  f === 0 && (Gn("No dependencies found, nothing to do."), Xe());
  let d = 0;
  for (const y of Object.keys(l))
    d += Object.keys(l[y]).length;
  d || (Gn("All dependencies are up to date."), Xe());
  const p = jc(l);
  if (o) {
    for (const y of Object.keys(l))
      if (Object.keys(l[y]).length) {
        try {
          const E = y === "npm" ? Gc : Uc;
          await Hc(u[y], E(c[y], l[y]));
        } catch (E) {
          throw new Error(`Error writing ${ct(u[y])}: ${E.message}`);
        }
        console.info(br(`✨ ${ct(u[y])} updated`));
      }
  }
  process.exit(p);
}
Yc().catch(Xe).then(Xe);
var Cs = {}, ye = {};
Object.defineProperty(ye, "__esModule", { value: !0 });
ye.TomlError = void 0;
function Zc(t, e) {
  let r = t.slice(0, e).split(/\r\n|\n|\r/g);
  return [r.length, r.pop().length + 1];
}
function Qc(t, e, r) {
  let n = t.split(/\r\n|\n|\r/g), i = "", s = (Math.log10(e + 1) | 0) + 1;
  for (let o = e - 1; o <= e + 1; o++) {
    let l = n[o - 1];
    l && (i += o.toString().padEnd(s, " "), i += ":  ", i += l, i += `
`, o === e && (i += " ".repeat(s + r + 2), i += `^
`));
  }
  return i;
}
class Jc extends Error {
  line;
  column;
  codeblock;
  constructor(e, r) {
    const [n, i] = Zc(r.toml, r.ptr), s = Qc(r.toml, n, i);
    super(`Invalid TOML document: ${e}

${s}`, r), this.line = n, this.column = i, this.codeblock = s;
  }
}
ye.TomlError = Jc;
var Qe = {};
Object.defineProperty(Qe, "__esModule", { value: !0 });
Qe.TomlDate = void 0;
let eu = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}:\d{2}(?:\.\d+)?)?(Z|[-+]\d{2}:\d{2})?$/i;
class He extends Date {
  #r = !1;
  #i = !1;
  #t = null;
  constructor(e) {
    let r = !0, n = !0, i = "Z";
    if (typeof e == "string") {
      let s = e.match(eu);
      s ? (s[1] || (r = !1, e = `0000-01-01T${e}`), n = !!s[2], s[2] && +s[2] > 23 ? e = "" : (i = s[3] || null, e = e.toUpperCase(), i || (e += "Z"))) : e = "";
    }
    super(e), isNaN(this.getTime()) || (this.#r = r, this.#i = n, this.#t = i);
  }
  isDateTime() {
    return this.#r && this.#i;
  }
  isLocal() {
    return !this.#r || !this.#i || !this.#t;
  }
  isDate() {
    return this.#r && !this.#i;
  }
  isTime() {
    return this.#i && !this.#r;
  }
  isValid() {
    return this.#r || this.#i;
  }
  toISOString() {
    let e = super.toISOString();
    if (this.isDate())
      return e.slice(0, 10);
    if (this.isTime())
      return e.slice(11, 23);
    if (this.#t === null)
      return e.slice(0, -1);
    if (this.#t === "Z")
      return e;
    let r = +this.#t.slice(1, 3) * 60 + +this.#t.slice(4, 6);
    return r = this.#t[0] === "-" ? r : -r, new Date(this.getTime() - r * 6e4).toISOString().slice(0, -1) + this.#t;
  }
  static wrapAsOffsetDateTime(e, r = "Z") {
    let n = new He(e);
    return n.#t = r, n;
  }
  static wrapAsLocalDateTime(e) {
    let r = new He(e);
    return r.#t = null, r;
  }
  static wrapAsLocalDate(e) {
    let r = new He(e);
    return r.#i = !1, r.#t = null, r;
  }
  static wrapAsLocalTime(e) {
    let r = new He(e);
    return r.#r = !1, r.#t = null, r;
  }
}
Qe.TomlDate = He;
var It = {}, de = {}, Ie = {}, te = {};
Object.defineProperty(te, "__esModule", { value: !0 });
te.getStringEnd = te.skipUntil = te.skipVoid = te.skipComment = te.indexOfNewline = void 0;
const Ns = ye;
function fr(t, e = 0, r = t.length) {
  let n = t.indexOf(`
`, e);
  return t[n - 1] === "\r" && n--, n <= r ? n : -1;
}
te.indexOfNewline = fr;
function Ls(t, e) {
  for (let r = e; r < t.length; r++) {
    let n = t[r];
    if (n === `
`)
      return r;
    if (n === "\r" && t[r + 1] === `
`)
      return r + 1;
    if (n < " " && n !== "	" || n === "")
      throw new Ns.TomlError("control characters are not allowed in comments", {
        toml: t,
        ptr: e
      });
  }
  return t.length;
}
te.skipComment = Ls;
function Ds(t, e, r, n) {
  let i;
  for (; (i = t[e]) === " " || i === "	" || !r && (i === `
` || i === "\r" && t[e + 1] === `
`); )
    e++;
  return n || i !== "#" ? e : Ds(t, Ls(t, e), r);
}
te.skipVoid = Ds;
function tu(t, e, r, n, i = !1) {
  if (!n)
    return e = fr(t, e), e < 0 ? t.length : e;
  for (let s = e; s < t.length; s++) {
    let o = t[s];
    if (o === "#")
      s = fr(t, s);
    else {
      if (o === r)
        return s + 1;
      if (o === n)
        return s;
      if (i && (o === `
` || o === "\r" && t[s + 1] === `
`))
        return s;
    }
  }
  throw new Ns.TomlError("cannot find end of structure", {
    toml: t,
    ptr: e
  });
}
te.skipUntil = tu;
function ru(t, e) {
  let r = t[e], n = r === t[e + 1] && t[e + 1] === t[e + 2] ? t.slice(e, e + 3) : r;
  e += n.length - 1;
  do
    e = t.indexOf(n, ++e);
  while (e > -1 && r !== "'" && t[e - 1] === "\\" && t[e - 2] !== "\\");
  return e > -1 && (e += n.length, n.length > 1 && (t[e] === r && e++, t[e] === r && e++)), e;
}
te.getStringEnd = ru;
Object.defineProperty(Ie, "__esModule", { value: !0 });
Ie.parseValue = Ie.parseString = void 0;
const Vn = te, nu = Qe, pe = ye;
let su = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, iu = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, ou = /^[+-]?0[0-9_]/, au = /^[0-9a-f]{4,8}$/i, Wn = {
  b: "\b",
  t: "	",
  n: `
`,
  f: "\f",
  r: "\r",
  '"': '"',
  "\\": "\\"
};
function lu(t, e = 0, r = t.length) {
  let n = t[e] === "'", i = t[e++] === t[e] && t[e] === t[e + 1];
  i && (r -= 2, t[e += 2] === "\r" && e++, t[e] === `
` && e++);
  let s = 0, o, l = "", a = e;
  for (; e < r - 1; ) {
    let c = t[e++];
    if (c === `
` || c === "\r" && t[e] === `
`) {
      if (!i)
        throw new pe.TomlError("newlines are not allowed in strings", {
          toml: t,
          ptr: e - 1
        });
    } else if (c < " " && c !== "	" || c === "")
      throw new pe.TomlError("control characters are not allowed in strings", {
        toml: t,
        ptr: e - 1
      });
    if (o) {
      if (o = !1, c === "u" || c === "U") {
        let u = t.slice(e, e += c === "u" ? 4 : 8);
        if (!au.test(u))
          throw new pe.TomlError("invalid unicode escape", {
            toml: t,
            ptr: s
          });
        try {
          l += String.fromCodePoint(parseInt(u, 16));
        } catch {
          throw new pe.TomlError("invalid unicode escape", {
            toml: t,
            ptr: s
          });
        }
      } else if (i && (c === `
` || c === " " || c === "	" || c === "\r")) {
        if (e = (0, Vn.skipVoid)(t, e - 1, !0), t[e] !== `
` && t[e] !== "\r")
          throw new pe.TomlError("invalid escape: only line-ending whitespace may be escaped", {
            toml: t,
            ptr: s
          });
        e = (0, Vn.skipVoid)(t, e);
      } else if (c in Wn)
        l += Wn[c];
      else
        throw new pe.TomlError("unrecognized escape sequence", {
          toml: t,
          ptr: s
        });
      a = e;
    } else
      !n && c === "\\" && (s = e - 1, o = !0, l += t.slice(a, s));
  }
  return l + t.slice(a, r - 1);
}
Ie.parseString = lu;
function cu(t, e, r) {
  if (t === "true")
    return !0;
  if (t === "false")
    return !1;
  if (t === "-inf")
    return -1 / 0;
  if (t === "inf" || t === "+inf")
    return 1 / 0;
  if (t === "nan" || t === "+nan" || t === "-nan")
    return NaN;
  if (t === "-0")
    return 0;
  let n;
  if ((n = su.test(t)) || iu.test(t)) {
    if (ou.test(t))
      throw new pe.TomlError("leading zeroes are not allowed", {
        toml: e,
        ptr: r
      });
    let s = +t.replace(/_/g, "");
    if (isNaN(s))
      throw new pe.TomlError("invalid number", {
        toml: e,
        ptr: r
      });
    if (n && !Number.isSafeInteger(s))
      throw new pe.TomlError("integer value cannot be represented losslessly", {
        toml: e,
        ptr: r
      });
    return s;
  }
  let i = new nu.TomlDate(t);
  if (!i.isValid())
    throw new pe.TomlError("invalid value", {
      toml: e,
      ptr: r
    });
  return i;
}
Ie.parseValue = cu;
var ze = {}, Xn;
function Ps() {
  if (Xn)
    return ze;
  Xn = 1;
  Object.defineProperty(ze, "__esModule", { value: !0 }), ze.extractValue = void 0;
  const t = Ie, e = js(), r = te, n = ye;
  function i(o, l, a, c) {
    let u = o.slice(l, a), f = u.indexOf("#");
    f > -1 && ((0, r.skipComment)(o, f), u = u.slice(0, f));
    let d = u.trimEnd();
    if (!c) {
      let p = u.indexOf(`
`, d.length);
      if (p > -1)
        throw new n.TomlError("newlines are not allowed in inline tables", {
          toml: o,
          ptr: l + p
        });
    }
    return [d, f];
  }
  function s(o, l, a) {
    let c = o[l];
    if (c === "[" || c === "{") {
      let [d, p] = c === "[" ? (0, e.parseArray)(o, l) : (0, e.parseInlineTable)(o, l), y = (0, r.skipUntil)(o, p, ",", a);
      if (a === "}") {
        let E = (0, r.indexOfNewline)(o, p, y);
        if (E > -1)
          throw new n.TomlError("newlines are not allowed in inline tables", {
            toml: o,
            ptr: E
          });
      }
      return [d, y];
    }
    let u;
    if (c === '"' || c === "'") {
      u = (0, r.getStringEnd)(o, l);
      let d = (0, t.parseString)(o, l, u);
      if (a) {
        if (u = (0, r.skipVoid)(o, u, a !== "]"), o[u] && o[u] !== "," && o[u] !== a && o[u] !== `
` && o[u] !== "\r")
          throw new n.TomlError("unexpected character encountered", {
            toml: o,
            ptr: u
          });
        u += +(o[u] === ",");
      }
      return [d, u];
    }
    u = (0, r.skipUntil)(o, l, ",", a);
    let f = i(o, l, u - +(o[u - 1] === ","), a === "]");
    if (!f[0])
      throw new n.TomlError("incomplete key-value declaration: no value specified", {
        toml: o,
        ptr: l
      });
    return a && f[1] > -1 && (u = (0, r.skipVoid)(o, l + f[1]), u += +(o[u] === ",")), [
      (0, t.parseValue)(f[0], o, l),
      u
    ];
  }
  return ze.extractValue = s, ze;
}
var qn;
function js() {
  if (qn)
    return de;
  qn = 1;
  Object.defineProperty(de, "__esModule", { value: !0 }), de.parseArray = de.parseInlineTable = de.parseKey = void 0;
  const t = Ie, e = Ps(), r = te, n = ye;
  let i = /^[a-zA-Z0-9-_]+[ \t]*$/;
  function s(a, c, u = "=") {
    let f = c - 1, d = [], p = a.indexOf(u, c);
    if (p < 0)
      throw new n.TomlError("incomplete key-value: cannot find end of key", {
        toml: a,
        ptr: c
      });
    do {
      let y = a[c = ++f];
      if (y !== " " && y !== "	")
        if (y === '"' || y === "'") {
          if (y === a[c + 1] && y === a[c + 2])
            throw new n.TomlError("multiline strings are not allowed in keys", {
              toml: a,
              ptr: c
            });
          let E = (0, r.getStringEnd)(a, c);
          if (E < 0)
            throw new n.TomlError("unfinished string encountered", {
              toml: a,
              ptr: c
            });
          f = a.indexOf(".", E);
          let w = a.slice(E, f < 0 || f > p ? p : f), $ = (0, r.indexOfNewline)(w);
          if ($ > -1)
            throw new n.TomlError("newlines are not allowed in keys", {
              toml: a,
              ptr: c + f + $
            });
          if (w.trimStart())
            throw new n.TomlError("found extra tokens after the string part", {
              toml: a,
              ptr: E
            });
          if (p < E && (p = a.indexOf(u, E), p < 0))
            throw new n.TomlError("incomplete key-value: cannot find end of key", {
              toml: a,
              ptr: c
            });
          d.push((0, t.parseString)(a, c, E));
        } else {
          f = a.indexOf(".", c);
          let E = a.slice(c, f < 0 || f > p ? p : f);
          if (!i.test(E))
            throw new n.TomlError("only letter, numbers, dashes and underscores are allowed in keys", {
              toml: a,
              ptr: c
            });
          d.push(E.trimEnd());
        }
    } while (f + 1 && f < p);
    return [d, (0, r.skipVoid)(a, p + 1, !0, !0)];
  }
  de.parseKey = s;
  function o(a, c) {
    let u = {}, f = /* @__PURE__ */ new Set(), d, p = 0;
    for (c++; (d = a[c++]) !== "}" && d; ) {
      if (d === `
`)
        throw new n.TomlError("newlines are not allowed in inline tables", {
          toml: a,
          ptr: c - 1
        });
      if (d === "#")
        throw new n.TomlError("inline tables cannot contain comments", {
          toml: a,
          ptr: c - 1
        });
      if (d === ",")
        throw new n.TomlError("expected key-value, found comma", {
          toml: a,
          ptr: c - 1
        });
      if (d !== " " && d !== "	") {
        let y, E = u, w = !1, [$, _] = s(a, c - 1);
        for (let D = 0; D < $.length; D++) {
          if (D && (E = w ? E[y] : E[y] = {}), y = $[D], (w = Object.hasOwn(E, y)) && (typeof E[y] != "object" || f.has(E[y])))
            throw new n.TomlError("trying to redefine an already defined value", {
              toml: a,
              ptr: c
            });
          !w && y === "__proto__" && Object.defineProperty(E, y, { enumerable: !0, configurable: !0, writable: !0 });
        }
        if (w)
          throw new n.TomlError("trying to redefine an already defined value", {
            toml: a,
            ptr: c
          });
        let [G, C] = (0, e.extractValue)(a, _, "}");
        f.add(G), E[y] = G, c = C, p = a[c - 1] === "," ? c - 1 : 0;
      }
    }
    if (p)
      throw new n.TomlError("trailing commas are not allowed in inline tables", {
        toml: a,
        ptr: p
      });
    if (!d)
      throw new n.TomlError("unfinished table encountered", {
        toml: a,
        ptr: c
      });
    return [u, c];
  }
  de.parseInlineTable = o;
  function l(a, c) {
    let u = [], f;
    for (c++; (f = a[c++]) !== "]" && f; ) {
      if (f === ",")
        throw new n.TomlError("expected value, found comma", {
          toml: a,
          ptr: c - 1
        });
      if (f === "#")
        c = (0, r.skipComment)(a, c);
      else if (f !== " " && f !== "	" && f !== `
` && f !== "\r") {
        let d = (0, e.extractValue)(a, c - 1, "]");
        u.push(d[0]), c = d[1];
      }
    }
    if (!f)
      throw new n.TomlError("unfinished array encountered", {
        toml: a,
        ptr: c
      });
    return [u, c];
  }
  return de.parseArray = l, de;
}
Object.defineProperty(It, "__esModule", { value: !0 });
It.parse = void 0;
const Kn = js(), uu = Ps(), ir = te, at = ye;
function Yn(t, e, r, n) {
  let i = e, s = r, o, l = !1, a;
  for (let c = 0; c < t.length; c++) {
    if (c) {
      if (i = l ? i[o] : i[o] = {}, s = (a = s[o]).c, n === 0 && (a.t === 1 || a.t === 2))
        return null;
      if (a.t === 2) {
        let u = i.length - 1;
        i = i[u], s = s[u].c;
      }
    }
    if (o = t[c], (l = Object.hasOwn(i, o)) && s[o]?.t === 0 && s[o]?.d)
      return null;
    l || (o === "__proto__" && (Object.defineProperty(i, o, { enumerable: !0, configurable: !0, writable: !0 }), Object.defineProperty(s, o, { enumerable: !0, configurable: !0, writable: !0 })), s[o] = {
      t: c < t.length - 1 && n === 2 ? 3 : n,
      d: !1,
      i: 0,
      c: {}
    });
  }
  if (a = s[o], a.t !== n && !(n === 1 && a.t === 3) || (n === 2 && (a.d || (a.d = !0, i[o] = []), i[o].push(i = {}), a.c[a.i++] = a = { t: 1, d: !1, i: 0, c: {} }), a.d))
    return null;
  if (a.d = !0, n === 1)
    i = l ? i[o] : i[o] = {};
  else if (n === 0 && l)
    return null;
  return [o, i, a.c];
}
function fu(t) {
  let e = {}, r = {}, n = e, i = r;
  for (let s = (0, ir.skipVoid)(t, 0); s < t.length; ) {
    if (t[s] === "[") {
      let o = t[++s] === "[", l = (0, Kn.parseKey)(t, s += +o, "]");
      if (o) {
        if (t[l[1] - 1] !== "]")
          throw new at.TomlError("expected end of table declaration", {
            toml: t,
            ptr: l[1] - 1
          });
        l[1]++;
      }
      let a = Yn(
        l[0],
        e,
        r,
        o ? 2 : 1
        /* Type.EXPLICIT */
      );
      if (!a)
        throw new at.TomlError("trying to redefine an already defined table or value", {
          toml: t,
          ptr: s
        });
      i = a[2], n = a[1], s = l[1];
    } else {
      let o = (0, Kn.parseKey)(t, s), l = Yn(
        o[0],
        n,
        i,
        0
        /* Type.DOTTED */
      );
      if (!l)
        throw new at.TomlError("trying to redefine an already defined table or value", {
          toml: t,
          ptr: s
        });
      let a = (0, uu.extractValue)(t, o[1]);
      l[1][l[0]] = a[0], s = a[1];
    }
    if (s = (0, ir.skipVoid)(t, s, !0), t[s] && t[s] !== `
` && t[s] !== "\r")
      throw new at.TomlError("each key-value declaration must be followed by an end-of-line", {
        toml: t,
        ptr: s
      });
    s = (0, ir.skipVoid)(t, s);
  }
  return e;
}
It.parse = fu;
var xt = {};
Object.defineProperty(xt, "__esModule", { value: !0 });
xt.stringify = void 0;
const Hs = /^[a-z0-9-_]+$/i;
function Ct(t) {
  let e = typeof t;
  if (e === "object") {
    if (Array.isArray(t))
      return "array";
    if (t instanceof Date)
      return "date";
  }
  return e;
}
function hu(t) {
  for (let e = 0; e < t.length; e++)
    if (Ct(t[e]) !== "object")
      return !1;
  return t.length != 0;
}
function Tr(t) {
  return JSON.stringify(t).replace(/\x7f/g, "\\u007f");
}
function Ir(t, e = Ct(t)) {
  if (e === "number")
    return isNaN(t) ? "nan" : t === 1 / 0 ? "inf" : t === -1 / 0 ? "-inf" : t.toString();
  if (e === "bigint" || e === "boolean")
    return t.toString();
  if (e === "string")
    return Tr(t);
  if (e === "date") {
    if (isNaN(t.getTime()))
      throw new TypeError("cannot serialize invalid date");
    return t.toISOString();
  }
  if (e === "object")
    return pu(t);
  if (e === "array")
    return du(t);
}
function pu(t) {
  let e = Object.keys(t);
  if (e.length === 0)
    return "{}";
  let r = "{ ";
  for (let n = 0; n < e.length; n++) {
    let i = e[n];
    n && (r += ", "), r += Hs.test(i) ? i : Tr(i), r += " = ", r += Ir(t[i]);
  }
  return r + " }";
}
function du(t) {
  if (t.length === 0)
    return "[]";
  let e = "[ ";
  for (let r = 0; r < t.length; r++) {
    if (r && (e += ", "), t[r] === null || t[r] === void 0)
      throw new TypeError("arrays cannot contain null or undefined values");
    e += Ir(t[r]);
  }
  return e + " ]";
}
function gu(t, e) {
  let r = "";
  for (let n = 0; n < t.length; n++)
    r += `[[${e}]]
`, r += xr(t[n], e), r += `

`;
  return r;
}
function xr(t, e = "") {
  let r = "", n = "", i = Object.keys(t);
  for (let s = 0; s < i.length; s++) {
    let o = i[s];
    if (t[o] !== null && t[o] !== void 0) {
      let l = Ct(t[o]);
      if (l === "symbol" || l === "function")
        throw new TypeError(`cannot serialize values of type '${l}'`);
      let a = Hs.test(o) ? o : Tr(o);
      if (l === "array" && hu(t[o]))
        n += gu(t[o], e ? `${e}.${a}` : a);
      else if (l === "object") {
        let c = e ? `${e}.${a}` : a;
        n += `[${c}]
`, n += xr(t[o], c), n += `

`;
      } else
        r += a, r += " = ", r += Ir(t[o], l), r += `
`;
    }
  }
  return `${r}
${n}`.trim();
}
function mu(t) {
  if (Ct(t) !== "object")
    throw new TypeError("stringify can only be called with an object");
  return xr(t);
}
xt.stringify = mu;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.stringify = t.parse = t.TomlDate = t.TomlError = void 0;
  var e = ye;
  Object.defineProperty(t, "TomlError", { enumerable: !0, get: function() {
    return e.TomlError;
  } });
  var r = Qe;
  Object.defineProperty(t, "TomlDate", { enumerable: !0, get: function() {
    return r.TomlDate;
  } });
  var n = It;
  Object.defineProperty(t, "parse", { enumerable: !0, get: function() {
    return n.parse;
  } });
  var i = xt;
  Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
    return i.stringify;
  } });
})(Cs);
const Eu = /* @__PURE__ */ Xs({
  __proto__: null
}, [Cs]);
